<?xml version="1.0" encoding="utf-8" ?>
<CodeGeneration RefDataNamespace="My.Hr.Common.Entities" RefDataText="true" EventSubjectRoot="My" EventActionFormat="PastTense" AppBasedAgentArgs="true" WebApiAutoLocation="true" DatabaseSchema="Hr" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://github.com/Avanade/Beef/raw/master/tools/Beef.CodeGen.Core/Schema/codegen.entity.xsd">
  <!-- Creating an Employee base with only the subset of fields that we want returned from the GetByArgs.
       - As we will be returning more than one we need the Collection and CollectionResult.
       - Any Text with a handlebars '{{xxx}}' is a shortcut for .NET see comments; e.g. '<see cref="xxx"/>'.
       - ExcludeAll is used so only the entity (not other layers are generated); with the exception of ExcludeData of false where it is a special case to output a DataMapper.
       - Use of DataName is to reference the name of the column where different to the property name iteself.
       - Use of DataAutoGenerated indicates that the data source will automatically generate the value.
       - A Type with RefDataNamespace.* is how to reference a reference data entity (will default RefDataType to 'string').
       - A DateTimeTransform of DateOnly is used to indicate that the DateTime property should only be concerned with the Date component.
       - ETag and ChangeLog are special case and Beef will automatically map between RowVersion and other Audit columns where they exist. 
       - AutoImplement of Database will ensure that the DbMapper is generated; used by the Employee.Get/Create/Update. 
       - By specifying the EntityFrameworkEntity the EfMapper (mapping to defined type will be mapped) will also be generated; used by the Employee.GetByArgs.
       - The Termination property DataEntityFrameworkIgnore is set as this cannot be automatically generated; custom code will need to be developed to handle; used by the Employee.GetByArgs. -->
  <Entity Name="EmployeeBase" Text="{{Employee}} base" Collection="true" CollectionResult="true" ExcludeAll="true" ExcludeData="false" AutoImplement="Database" EntityFrameworkEntity="EfModel.Employee" >
    <Property Name="Id" Type="Guid" Text="{{Employee}} identifier" UniqueKey="true" DataName="EmployeeId" DataAutoGenerated="true" />
    <Property Name="Email" Type="string" Text="Unique {{Employee}} Email" />
    <Property Name="FirstName" Type="string" />
    <Property Name="LastName" Type="string" />
    <Property Name="Gender" Type="RefDataNamespace.Gender" DataName="GenderCode" />
    <Property Name="Birthday" Type="DateTime" DateTimeTransform="DateOnly" />
    <Property Name="StartDate" Type="DateTime" DateTimeTransform="DateOnly" />
    <Property Name="Termination" Type="TerminationDetail" DataDatabaseMapper="TerminationDetailData.DbMapper" DataEntityFrameworkIgnore="true" />
    <Property Name="PhoneNo" Type="string" />
    <Property Name="ETag" Type="string" />
    <Property Name="ChangeLog" Type="ChangeLog" />
  </Entity>

  <!-- Creating an Employee inheriting from EmployeeBase (DataMapper will also inherit).
       - The Id is re-specified, but marked as inherited, as is needed to assist with the operations that reference the UniqueKey.
       - The Validator is specified, which is then used by both the Create and Update operations.
       - The AutoImplement specifies that operations should be auto-implemented using Database (ADO.NET) unless explicitly overridden.
       - The WebApiRoutePrefix is defined, which is in turn extended by each operation. 
       - The EntityFrameworkEntity is required so that the GetByArgs code-gen knows what EfModel is to be used; however, DataEntityFrameworkCustomMapper is also used so that a corresponding EfMapper is not output (not required). -->
  <Entity Name="Employee" Inherits="EmployeeBase" Validator="EmployeeValidator" WebApiRoutePrefix="api/v1/employees" AutoImplement="Database" DataDatabaseMapperInheritsFrom="EmployeeBaseData.DbMapper" EntityFrameworkEntity="EfModel.Employee" DataEntityFrameworkCustomMapper="true">
    <Property Name="Id" Text="{{Employee}} identifier" Type="Guid" UniqueKey="true" Inherited="true" DataDatabaseIgnore="true" />
    <Property Name="Address" Type="Address" DataConverter="ObjectToJsonConverter{T}" DataName="AddressJson"/>
    <Property Name="EmergencyContacts" Type="EmergencyContactCollection" DataDatabaseIgnore="true" />

    <!-- CRUD operations:
         - Get - Get by unique identifier which it infers from the properties marked as UniqueKey; data access cannot be automatically implemented given complexity.
         - Create/Update/Patch - infers UniqueKey where appropriate; data access cannot be automatically implemented given complexity (Patch is Controller-only, reuses Get and Update to perform). 
         - Delete - explictly defining so that we can tie further validation to the identifier check. 
                  - Using the Property attribute to copy configuration from the Entity itself.
                  - Providing further validation by using the Common extension method to invoke the EmployeeValidator.CanDelete. -->
    <Operation Name="Get" OperationType="Get" UniqueKey="true" WebApiRoute="{id}" AutoImplement="None" />
    <Operation Name="Create" OperationType="Create" WebApiRoute="" AutoImplement="None" />
    <Operation Name="Update" OperationType="Update" UniqueKey="true" WebApiRoute="{id}" AutoImplement="None" />
    <Operation Name="Patch" OperationType="Patch" UniqueKey="true" WebApiRoute="{id}" />
    <Operation Name="Delete" OperationType="Delete" WebApiRoute="{id}">
      <Parameter Name="Id" Property="Id" IsMandatory="true" ValidatorFluent="Common(EmployeeValidator.CanDelete)"/>
    </Operation>
  
    <!-- Search operation 
         - OperationType is GetColl which indicates that a collection is the expected result. 
         - ReturnType is overriding the default Employee as we want to use EmployeeBase (reduced set of fields). 
         - PagingArgs indicates to Beef that paging support is required and to be automatically enabled for the operation. 
         - AutoImplement of EntityFramework informs code-gen to output EntityFramework code versus database stored procedures.
         - Parameter defines the parameter being the EmployeeArgs (defined) and that the value should be validated. -->
    <Operation Name="GetByArgs" OperationType="GetColl" PagingArgs="true" ReturnType="EmployeeBase" WebApiRoute="" AutoImplement="EntityFramework" DataEntityMapper="EmployeeBaseData.EfMapper" >
      <Parameter Name="Args" Type="EmployeeArgs" Validator="EmployeeArgsValidator" />
    </Operation>
  
    <!-- Terminate operation
         - Text is specified to override the default for an Update.
         - OperationType is Update as it follows a similar pattern. 
         - ValueType is overridden with the TerminationDetail to use this instead of the default Employee. 
         - Validator is overridden to use the TerminationDetailValidator. 
         - WebApiMethod is overriden to use HttpPost (an Update otherwise defaults to an HttpPut).
         - EventSubject is overridden so that the action component will be Terminated. 
         - AutoImplement is None as this will be implemented by the developer.
         - An additional Id parameter is passed; in this instance we do not use the UniqueKey as we require the value to be passed down all the layers. -->
    <Operation Name="Terminate" Text="Terminates an existing {{Employee}}" OperationType="Update" ValueType="TerminationDetail" Validator="TerminationDetailValidator" WebApiRoute="{id}/terminate" WebApiMethod="HttpPost" EventSubject="Hr.Employee.{id}:Terminated" AutoImplement="None">
      <Parameter Name="Id" Type="Guid" Text="{{Employee}} identifier" />
    </Operation>
  </Entity>

  <!-- Creating a TerminationDetail with Date and Reason.
       - ExcludeAll is used so only the entity (not other layers are generated); with the exception of ExcludeData of false where it is a special case to output a DataMapper. 
       - By specifying the EntityFrameworkEntity the EfMapper (mapping to defined type will be mapped) will also be generated; used by the Employee.GetByArgs. -->
  <Entity Name="TerminationDetail" ExcludeAll="true" ExcludeData="false" AutoImplement="Database" EntityFrameworkEntity="EfModel.Employee">
    <Property Name="Date" Type="DateTime" DateTimeTransform="DateOnly" DataName="TerminationDate" />
    <Property Name="Reason" Type="RefDataNamespace.TerminationReason" DataName="TerminationReasonCode" />
  </Entity>

  <!-- Creating an Address.
       - ExcludeAll is used so only the entity (not other layers are generated); no ExcludeData required as no mapper is needed as converting to JSON. -->
  <Entity Name="Address" ExcludeAll="true">
    <Property Name="Street1" Type="string" />
    <Property Name="Street2" Type="string" />
    <Property Name="City" Type="string" />
    <Property Name="State" Type="RefDataNamespace.USState" />
    <Property Name="PostCode" Type="string" />
  </Entity>

  <!-- Creating a EmergencyContact and corresponding collection.
       - ExcludeAll is used so only the entity (not other layers are generated); with the exception of ExcludeData of false where it is a special case to output a DataMapper. -->
  <Entity Name="EmergencyContact" Collection="true" ExcludeAll="true" ExcludeData="false" AutoImplement="Database" >
    <Property Name="Id" Type="Guid" UniqueKey="true" DataName="EmergencyContactId" />
    <Property Name="FirstName" Type="string" />
    <Property Name="LastName" Type="string" />
    <Property Name="PhoneNo" Type="string" />
    <Property Name="Relationship" Type="RefDataNamespace.RelationshipType" DataName="RelationshipTypeCode" />
  </Entity>
  
  <!-- Creating an EmployeeArgs entity
       - Genders will support a list (none or more) reference data values.
       - StartFrom, StartTo and IncludeTerminated are all Nullable so we can tell whether a value was provided or not. 
       - ExcludeAll is used so only the entity (not other layers are generated).
       - The IsIncludeTerminated overrides the JsonName to meet the stated requirement name of includeTerminated. -->
  <Entity Name="EmployeeArgs" Text="{{Employee}} search arguments" ExcludeAll="true" >
    <Property Name="FirstName" Type="string" />
    <Property Name="LastName" Type="string" />
    <Property Name="Genders" Type="RefDataNamespace.Gender" RefDataList="true" />
    <Property Name="StartFrom" Type="DateTime?" DateTimeTransform="DateOnly" />
    <Property Name="StartTo" Type="DateTime?" DateTimeTransform="DateOnly" />
    <Property Name="IsIncludeTerminated" JsonName="includeTerminated" Type="bool?" />
  </Entity>

  <!-- Creating a PerformanceReview entity
       - Collection and CollectionResult required by GetByEmployeeId operation. 
       - WebApiRoutPrefix does not include entity as this will differ per operation (where more explicitly stated). 
       - Default is to AutoImplement using EntityFramework against the EfModel.PerformanceReview generated from the database.
       - EmployeeId is made immutable within mapper by specifing DataOperationTypes as AnyExceptUpdate; i.e. the value will never map (override) on an update. -->
  <Entity Name="PerformanceReview" Collection="true" CollectionResult="true" Validator="PerformanceReviewValidator" WebApiRoutePrefix="api/v1" AutoImplement="EntityFramework" EntityFrameworkEntity="EfModel.PerformanceReview">
    <Property Name="Id" Type="Guid" Text="{{Employee}} identifier" UniqueKey="true" DataName="PerformanceReviewId" DataAutoGenerated="true" />
    <Property Name="EmployeeId" Text="{{Employee.Id}} (value is immutable)" Type="Guid" DataOperationTypes="AnyExceptUpdate" />
    <Property Name="Date" Type="DateTime" />
    <Property Name="Outcome" Type="RefDataNamespace.PerformanceOutcome" DataName="PerformanceOutcomeCode" />
    <Property Name="Reviewer" Type="string" />
    <Property Name="Notes" Type="string" />
    <Property Name="ETag" Type="string" />
    <Property Name="ChangeLog" Type="ChangeLog" IsEntity="true" />
    
    <!-- Operations 
         Get - this is a simple Get by unique key (being the Id) which will be automatically implemented.
         GetByEmployeeId - this requires the EmployeeId to be passed in via the URI which is filtered within the developer extension.
         Create - this requires the EmployeeId to be passed in via the URI which will override the value in the entity within the Manager layer (as defined by LayerPassing value of ToManagerSet).
         Update/Patch/Delete - are all automatically implemented as they all simply follow the standard pattern. -->
    <Operation Name="Get" OperationType="Get" UniqueKey="true" WebApiRoute="reviews/{id}" />
    <Operation Name="GetByEmployeeId" OperationType="GetColl" PagingArgs="true" WebApiRoute="employees/{employeeId}/reviews">
      <Parameter Name="EmployeeId" Text="{{Employee.Id}}" Type="Guid" />
    </Operation>
    <Operation Name="Create" OperationType="Create" WebApiRoute="employees/{employeeId}/reviews">
      <Parameter Name="EmployeeId" Text="{{Employee.Id}}" Type="Guid" LayerPassing="ToManagerSet" />
    </Operation>
    <Operation Name="Update" OperationType="Update" UniqueKey="true" WebApiRoute="reviews/{id}" />
    <Operation Name="Patch" OperationType="Patch" UniqueKey="true" WebApiRoute="reviews/{id}" />
    <Operation Name="Delete" OperationType="Delete" UniqueKey="true" WebApiRoute="reviews/{id}" />
  </Entity>
</CodeGeneration>