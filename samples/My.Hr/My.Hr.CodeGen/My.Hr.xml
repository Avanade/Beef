<?xml version="1.0" encoding="utf-8" ?>
<CodeGeneration RefDataNamespace="My.Hr.Common.Entities" RefDataText="true" EventSubjectRoot="My" EventActionFormat="PastTense" xmlns="http://schemas.beef.com/codegen/2015/01/entity" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://github.com/Avanade/Beef/raw/master/tools/Beef.CodeGen.Core/Schema/codegen.entity.xsd">
  <!-- Creating an Employee base with only the subset of fields that we want returned from the GetByArgs.
       - As we will be returning more than one we need the Collection and CollectionResult.
       - Any Text with a handlebars '{{xxx}}' is a shortcut for .NET see comments; e.g. '<see cref="xxx"/>'.
       - ExcludeAll is used so only the entity (not other layers are generated); with the exception of ExcludeData of false where it is a special case to output a DataMapper.
       - Use of DataName is to reference the name of the column where different to the property name iteself.
       - Use of DataAutoGenerated indicates that the data source will automatically generate the value.
       - A Type with RefDataNamespace.* is how to reference a reference data entity (will default RefDataType to 'string').
       - A DateTimeTransform of DateOnly is used to indicate that the DateTime property should only be concerned with the Date component.
       - ETag and ChangeLog are special case and Beef will automatically map between RowVersion and other Audit columns where they exist. 
       - AutoImplement of Database will ensure that the DbMapper is generated; used by the Employee.Get/Create/Update. 
       - By specifying the EntityFrameworkEntity the EfMapper (mapping to defined type will be mapped) will also be generated; used by the Employee.GetByArgs.
       - The Termination property DataEntityFrameworkIgnore is set as this cannot be automatically generated; custom code will need to be developed to handle; used by the Employee.GetByArgs. -->
  <Entity Name="EmployeeBase" Text="{{Employee}} base" Collection="true" CollectionResult="true" ExcludeAll="true" ExcludeData="false" AutoImplement="Database" EntityFrameworkEntity="EfModel.Employee" >
    <Property Name="Id" Type="Guid" Text="{{Employee}} identifier" UniqueKey="true" DataName="EmployeeId" DataAutoGenerated="true" />
    <Property Name="Email" Type="string" Text="Unique {{Employee}} Email" />
    <Property Name="FirstName" Type="string" />
    <Property Name="LastName" Type="string" />
    <Property Name="Gender" Type="RefDataNamespace.Gender" DataName="GenderCode" />
    <Property Name="Birthday" Type="DateTime" DateTimeTransform="DateOnly" />
    <Property Name="StartDate" Type="DateTime" DateTimeTransform="DateOnly" />
    <Property Name="Termination" Type="TerminationDetail" DataDatabaseMapper="TerminationDetailData.DbMapper" DataEntityFrameworkIgnore="true" />
    <Property Name="PhoneNo" Type="string" />
    <Property Name="ETag" ArgumentName="etag" Type="string" />
    <Property Name="ChangeLog" Type="ChangeLog" IsEntity="true" />
  </Entity>

  <!-- Creating an Employee inheriting from EmployeeBase (DataMapper will also inherit).
       - The Id is re-specified, but marked as inherited, as is needed to assist with the operations that reference the UniqueKey.
       - The Validator is specified, which is then used by both the Create and Update operations.
       - The AutoImplement specifies that operations should be auto-implemented using Database (ADO.NET) unless explicitly overridden.
       - The WebApiRoutePrefix is defined, which is in turn extended by each operation. 
       - The EntityFrameworkEntity is required so that the GetByArgs code-gen knows what EfModel is to be used; however, DataEntityFrameworkCustomMapper is also used so that a corresponding EfMapper is not output (not required). -->
  <Entity Name="Employee" Inherits="EmployeeBase" Validator="EmployeeValidator" WebApiRoutePrefix="api/v1/employees" AutoImplement="Database" DatabaseSchema="Hr" DataDatabaseMapperInheritsFrom="EmployeeBaseData.DbMapper" EntityFrameworkEntity="EfModel.Employee" DataEntityFrameworkCustomMapper="true">
    <Property Name="Id" Type="Guid" UniqueKey="true" Inherited="true" DataDatabaseIgnore="true" />
    <Property Name="Address" Type="Address" DataConverter="ObjectToJsonConverter{T}" DataName="AddressJson"/>
    <Property Name="EmergencyContacts" Type="EmergencyContactCollection" DataDatabaseIgnore="true" />

    <!-- CRUD operations:
         - Get - Get by unique identifier which it infers from the properties marked as UniqueKey; data access cannot be automatically implemented given complexity.
         - Create/Update/Patch - infers UniqueKey where appropriate; data access cannot be automatically implemented given complexity (Patch is Controller-only, reuses Get and Update to perform). 
         - Delete - infers UniqueKey; can be automatically implemented as it will invoke stored procedure with key and expects no result. -->
    <Operation Name="Get" OperationType="Get" UniqueKey="true" WebApiRoute="{id}" AutoImplement="None" />
    <Operation Name="Create" OperationType="Create" WebApiRoute="" AutoImplement="None" />
    <Operation Name="Update" OperationType="Update" UniqueKey="true" WebApiRoute="{id}" AutoImplement="None" />
    <Operation Name="Patch" OperationType="Patch" UniqueKey="true" WebApiRoute="{id}" />
    <Operation Name="Delete" OperationType="Delete" UniqueKey="true" WebApiRoute="{id}" />
  
    <!-- Search operation 
         - OperationType is GetColl which indicates that a collection is the expected result. 
         - ReturnType is overridding the default Employee as we want to use EmployeeBase (reduced set of fields). 
         - PagingArgs indicates to Beef that paging support is required and to be automatically enabled for the operation. 
         - AutoImplement of EntityFramework informs code-gen to output EntityFramework code versus database stored procedures.
         - Parameter defines the parameter being the EmployeeArgs (defined) and that the value should be validated. -->
    <Operation Name="GetByArgs" OperationType="GetColl" PagingArgs="true" ReturnType="EmployeeBase" WebApiRoute="" AutoImplement="EntityFramework" DataEntityMapper="EmployeeBaseData.EfMapper" >
      <Parameter Name="Args" Type="EmployeeArgs" Validator="EmployeeArgsValidator" />
    </Operation>
  
    <!-- Terminate operation
         - Text is specified to override the default for an Update.
         - OperationType is Update as it follows a similar pattern. 
         - ValueType is overridden with the TerminationDetail to use this instead of the default Employee. 
         - Validator is overridden to use the TerminationDetailValidator. 
         - WebApiMethod is overriden to use HttpPost (an Update otherwise defaults to an HttpPut).
         - EventSubject is overridden so that the action component will be Terminated. 
         - AutoImplement is None as this will be implemented by the developer.
         - An additional Id parameter is passed; in this instance we do not use the UniqueKey as we require the value to be passed down all the layers. -->
    <Operation Name="Terminate" Text="Terminates an existing {{Employee}}" OperationType="Update" ValueType="TerminationDetail" Validator="TerminationDetailValidator" WebApiRoute="{id}/terminate" WebApiMethod="HttpPost" EventSubject="Hr.Employee.{id}:Terminated" AutoImplement="None">
      <Parameter Name="Id" Type="Guid" Text="{{Employee}} identifier" />
    </Operation>
  </Entity>

  <!-- Creating a TerminationDetail with Date and Reason.
       - ExcludeAll is used so only the entity (not other layers are generated); with the exception of ExcludeData of false where it is a special case to output a DataMapper. 
       - By specifying the EntityFrameworkEntity the EfMapper (mapping to defined type will be mapped) will also be generated; used by the Employee.GetByArgs. -->
  <Entity Name="TerminationDetail" ExcludeAll="true" ExcludeData="false" AutoImplement="Database" EntityFrameworkEntity="EfModel.Employee">
    <Property Name="Date" Type="DateTime" DateTimeTransform="DateOnly" DataName="TerminationDate" />
    <Property Name="Reason" Type="RefDataNamespace.TerminationReason" DataName="TerminationReasonCode" />
  </Entity>

  <!-- Creating an Address.
       - ExcludeAll is used so only the entity (not other layers are generated); no ExcludeData required as no mapper is needed as converting to JSON. -->
  <Entity Name="Address" ExcludeAll="true">
    <Property Name="Street1" Type="string" />
    <Property Name="Street2" Type="string" />
    <Property Name="City" Type="string" />
    <Property Name="State" Type="RefDataNamespace.USState" />
    <Property Name="PostCode" Type="string" />
  </Entity>

  <!-- Creating a EmergencyContact and corresponding collection.
       - ExcludeAll is used so only the entity (not other layers are generated); with the exception of ExcludeData of false where it is a special case to output a DataMapper. -->
  <Entity Name="EmergencyContact" Collection="true" ExcludeAll="true" ExcludeData="false" AutoImplement="Database" >
    <Property Name="Id" Type="Guid" UniqueKey="true" DataName="EmergencyContactId" />
    <Property Name="FirstName" Type="string" />
    <Property Name="LastName" Type="string" />
    <Property Name="PhoneNo" Type="string" />
    <Property Name="Relationship" Type="RefDataNamespace.RelationshipType" DataName="RelationshipTypeCode" />
  </Entity>
  
  <!-- Creating an EmployeeArgs entity
       - Genders will support a list (none or more) reference data values.
       - StartFrom, StartTo and IncludeTerminated are all Nullable so we can tell whether a value was provided or not. 
       - ExcludeAll is used so only the entity (not other layers are generated).
       - The IsIncludeTerminated overrides the JsonName to meet the stated requirement name of includeTerminated. -->
  <Entity Name="EmployeeArgs" Text="{{Employee}} search arguments" ExcludeAll="true" >
    <Property Name="FirstName" Type="string" />
    <Property Name="LastName" Type="string" />
    <Property Name="Genders" Type="RefDataNamespace.Gender" RefDataList="true" />
    <Property Name="StartFrom" Type="DateTime?" DateTimeTransform="DateOnly" />
    <Property Name="StartTo" Type="DateTime?" DateTimeTransform="DateOnly" />
    <Property Name="IsIncludeTerminated" JsonName="includeTerminated" Type="bool?" />
  </Entity>
</CodeGeneration>