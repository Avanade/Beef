schema: Demo
cdcSchema: DemoCdc
eventSubjectFormat: NameOnly
eventSourceKind: Relative
eventSourceRoot: /cdc
eventActionFormat: PastTense
eventOutbox: true
hasBeefDbo: false
cdcIdentifierMapping: true
autoDotNetRename: SnakeKebabToPascalCase
cdcExcludeColumnsFromETag: [ legacy_system_code ]
queries:
  # New "Query" configuration.
- { name: Table, schema: Test, view: true, viewName: vwTestQuery, excludeColumns: [ CreatedBy,  UpdatedBy ], permission: TestSec,
    joins: [
      { name: Person, schema: Demo, excludeColumns: [ CreatedDate,  UpdatedDate ], aliasColumns: [ RowVersion^RowVersionP ],
        on: [
          { name: PersonId, toColumn: TableId }
        ]
      }
    ]
  }
tables:

  # Override the OrgUnitId to bypass the automatic handling as already applied wihin the underlying view.
- { name: vwTestQuery, schema: Test, columnNameOrgUnitId: N/A,
    storedProcedures: [
      { name: GetByArgs, type: GetColl, storedProcedureName: spTestQueryGetByArgs,
        parameters: [
          { name: Name, nullable: true, operator: LIKE }
        ]
      }
    ]
  }

- { name: Table, schema: Test, efModel: true }

- { name: Table2, schema: Test, get: true, create: true, update: true, delete: true, upsert: true }

- { name: Table3, schema: Test, get: true, create: true, update: true, delete: true, upsert: true }

  # Special test to generate all variations.
- { name: Table, schema: Test, create: true, update: true, upsert: true, delete: true, merge: true, udt: true, getAll: true, getAllOrderBy: [ Name Des ], excludeColumns: [ Other ], orgUnitImmutable: true, permission: TestSec,
    storedProcedures: [
      { name: GetByArgs, type: GetColl, excludeColumns: [ Count ],
        parameters: [
          { name: Name, nullable: true, operator: LIKE },
          { name: MinCount, operator: GE, column: Count },
          { name: MaxCount, operator: LE, column: Count, nullable: true }
        ]
      },
      { name: Get, type: Get, withHints: NOLOCK,
        execute: [
          { statement: EXEC Demo.Before, location: Before },
          { statement: EXEC Demo.After }
        ]
      },
      { name: Update, type: Update }
    ]
  }

  # Reference data stored procedures
- { name: Gender, schema: Ref, getAll: true, get: true, create: true, update: true }

- { name: Country, schema: Ref, getAll: true }

- { name: USState, schema: Ref, getAll: true }

  # Reference data entity framework
- { name: EyeColor, schema: Ref, efModel: true }

- { name: Status, schema: Ref, efModel: true }

  # Master data stored procedures.
- { name: Person, schema: Demo, get: true, create: true, update: true, delete: true, efModel: true,
    storedProcedures: [
      { name: GetAll, paging: true,
        orderby: [
          { name: LastName, order: Ascending },
          { name: FirstName, order: Ascending }
        ]
      },
      { name: GetByArgs, paging: true,
        parameters: [
          { name: FirstName, nullable: true, collection: false, operator: LIKE },
          { name: LastName, nullable: true, collection: false, operator: LIKE },
          { name: GenderId, nullable: true, collection: true }
        ],
        orderby: [
          { name: LastName, order: Ascending },
          { name: FirstName, order: Ascending }
        ]
      },
      { name: GetDetailByArgs, paging: true, intoTempTable: true,
        parameters: [
          { name: FirstName, nullable: true, collection: false, operator: LIKE },
          { name: LastName, nullable: true, collection: false, operator: LIKE },
          { name: GenderId, nullable: true, collection: true }
        ],
        orderby: [
          { name: LastName, order: Ascending },
          { name: FirstName, order: Ascending }
        ],
        execute: [
          { statement: 'EXEC [Demo].[spWorkHistoryGetUsingTempTable]' }
        ]
      },
      { name: GetDetail, type: Get,
        execute: [
          { statement: 'EXEC [Demo].[spWorkHistoryGetByPersonId] @PersonId' }
        ]
      },
      { name: UpdateDetail, type: Update, reselectStatement: 'EXEC [Demo].[spPersonGetDetail] @PersonId',
        parameters: [
          { name: WorkHistoryList, sqlType: '[Demo].[udtWorkHistoryList] READONLY' }
        ],
        execute: [
          { statement: 'EXEC [Demo].[spWorkHistoryMerge] @PersonId, @WorkHistoryList', location: After }
        ]
      }
    ]
  }

- { name: WorkHistory, schema: Demo, udt: true, tvp: WorkHistory, udtExcludeColumns: [ PersonId ],
    storedProcedures: [
      { name: GetByPersonId, type: GetColl,
        parameters: [
          { name: PersonId }
        ],
        orderby: [
          { name: StartDate, order: Descending }
        ]
      },
      { name: Merge, type: Merge, mergeOverrideIdentityColumns: [ Name ],
        parameters: [
          { name: PersonId, sqlType: UNIQUEIDENTIFIER }
        ]
      },
      { name: GetUsingTempTable, type: GetColl,
        where: [
          { statement: '[PersonId] IN (SELECT [PersonId] from #p)' }
        ],
        orderby: [
          { name: PersonId, order: Ascending },
          { name: StartDate, order: Descending }
        ]
      }
    ]
  }

  # Check the generated output for the IsDeleted.
- { name: Person2, schema: Demo, create: true, update: true, upsert: true, delete: true, get: true, getAll: true }

  # Basic table with no row version or change log.
- { name: Contact, schema: Demo, efModel: true }
cdc:

  # Set up CDC for primary table Legacy.Contact.
- { name: Contact, schema: Legacy, eventSubject: Legacy.Contact, eventSubjectFormat: NameAndKey, identifierMapping: true, identifierMappingColumns: [ AlternateContactId^Contact ], aliasColumns: [ ContactId^CID ], excludeColumnsFromETag: [ legacy_system_code ],
    joins: [
      # Set up secondary One-To-One relationship from Legacy.Contact to Legacy.Address (1:1).
      # Join on Address.Id = Contact.AddressId.
      { name: Address, joinCardinality: OneToOne, identifierMapping: true, identifierMappingColumns: [ AlternateAddressId^Address ], aliasColumns: [ Id^AID ],
        on: [
          { name: Id, toColumn: AddressId }
        ]
      },
      # Set up inner join relationship from Legacy.Contact to Legacy.ContactMapping.
      # Left Outer Join (does not have to exist) on ContactMapping.ContactId = Contact.ContactId.
      # Only include the joined 'UniqueId' column.
      { name: ContactMapping, type: Left, includeColumns: [ UniqueId ],
        on: [
          { name: ContactId }
        ]
      }
    ]
  }

  # Set up CDC for primary table Legacy.Posts.
  # Relational hierarchy: Legacy.Posts
  # - Legacy.Comments (1:n)
  # - Legacy.Tags (1:n)
  # - Legacy.Tags (1:n).
- { name: Posts, schema: Legacy, eventSubject: Legacy.Post, eventSubjectFormat: NameOnly,
    joins: [
      # Set up secondary One-To-Many relationship from Legacy.Posts to Legacy.Comments (1:n).
      # Join on Comments.PostsId = Posts.PostsId.
      { name: Comments, schema: Legacy, joinTo: Posts,
        on: [
          { name: PostsId, toColumn: PostsId }
        ]
      },
      # Set up secondary One-To-Many relationship from Legacy.Comments to Legacy.Tags (1:n).
      # Name as 'CommentsTags' for uniqueness for join referencing.
      # Exclude the 'ParentType' column as not necessary for publishing (i.e. internal to database).
      # Rename 'ParentId' column to `CommentsId`.
      # Join on Tags.ParentType = 'C' AND Tags.ParentId = Comments.CommentsId.
      { name: CommentsTags, schema: Legacy, tableName: Tags, joinTo: Comments, excludeColumns: [ ParentType ], aliasColumns: [ ParentId^CommentsId ],
        on: [
          { name: ParentType, toStatement: '''C''' },
          { name: ParentId, toColumn: CommentsId }
        ]
      },
      # Set up secondary One-To-Many relationship from Legacy.Posts to Legacy.Tags (1:n).
      # Name as 'PostsTags' for uniqueness for join referencing.
      # Exclude the 'ParentType' column as not necessary for publishing (i.e. internal to database).
      # Rename 'ParentId' column to `PostsId`.
      # Join on Tags.ParentType = 'P' AND Tags.ParentId = Posts.PostsId.
      { name: PostsTags, schema: Legacy, tableName: Tags, joinTo: Posts, excludeColumns: [ ParentType ], aliasColumns: [ ParentId^PostsId ],
        on: [
          { name: ParentType, toStatement: '''P''' },
          { name: ParentId, toColumn: PostsId }
        ]
      }
    ]
  }

  # Set up CDC for primary table Demo.Person (this is a _non-legacy_ scenario).
  # Relational hierarchy is not important as the primary table *is* (must be) updated always (ETag and Audit columns); therefore, they can be ignored.
  # Will retrieve the Id column only as the Get Business-logic will be used to retrieve and publish (as this enables the required Entity DTO).
- { name: Person, schema: Demo, includeColumns: [ PersonId ], eventSubject: Demo.Cdc.Person, dataCtorParams: [ Beef.Demo.Business.IPersonManager ] }

  # As above for Person2; validate logical delete.
- { name: Person2, schema: Demo, eventSubject: Demo.Cdc.Person2, includeColumnsOnDelete: [ UpdatedBy,  UpdatedDate ], excludeHostedService: true }

