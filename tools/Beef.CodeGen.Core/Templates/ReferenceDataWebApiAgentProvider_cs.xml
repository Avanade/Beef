<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright (c) Avanade. Licensed under the MIT License. See https://github.com/Avanade/Beef -->
<Template OutputGenDirName="Generated" OutputFileName="ReferenceDataAgentProvider.cs">
  <Set Name="System.ServiceClientName" Value="Config.WebApiServiceClient"/>
  <If Condition="System.ServiceClientName == null or System.ServiceClientName == ''">
    <Set Name="System.ServiceClientName" Value="'ServiceClient'"/>
  </If>
  <![CDATA[/*
 * This file is automatically generated; any changes will be lost. 
 */

using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Threading.Tasks;
using Beef.RefData;
using Beef.RefData.Caching;
using Beef.WebApi;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using {{Config.Company}}.{{Config.AppName}}.Common.Entities;
]]>
  <If Condition="Config.RefDataNamespace != null">
    <![CDATA[using RefDataNamespace = {{Config.RefDataNamespace}};
]]>
  </If>
  <![CDATA[
namespace {{Config.Company}}.{{Config.AppName}}.Common.Agents
{
    /// <summary>
    /// Provides the <see cref="ReferenceData"/> implementation using the corresponding Web API agent.
    /// </summary>
    public class ReferenceDataAgentProvider : RefDataNamespace.ReferenceData
    {
        private static readonly Dictionary<string, Type> _nameDict = new Dictionary<string, Type>();
        private static readonly Dictionary<Type, string> _typeDict = new Dictionary<Type, string>();

        private readonly ReferenceDataAgent _agent;
        private readonly Dictionary<Type, object> _cacheDict = new Dictionary<Type, object>();

        #region Ctor
        
        /// <summary>
        /// Static constructor.
        /// </summary>
        static ReferenceDataAgentProvider()
        {
]]>
  <Entity Condition="Entity.RefDataType != null and Entity.Abstract == false and Entity.EntityScope == 'Common'">
    <Set Name="Entity.EntityName" Condition="Config.RefDataNamespace == null" Value="${{Entity.Name}}" Otherwise="$RefDataNamespace.{{Entity.Name}}" />
    <Set Name="Entity.EntityCollectionName" Condition="Config.RefDataNamespace == null" Value="${{Entity.Name}}Collection" Otherwise="$RefDataNamespace.{{Entity.Name}}Collection" />
    <If Condition="System.Index > 0">
      <![CDATA[
]]>
    </If>
    <![CDATA[            _nameDict.Add(Property_{{Entity.Name}}, typeof({{Entity.EntityName}}));
            _typeDict.Add(typeof({{Entity.EntityName}}), Property_{{Entity.Name}});
]]>
  </Entity>
  <![CDATA[        }
        
        /// <summary>
        /// Initializes a new instance of the <see cref="ReferenceDataAgentProvider"/> class.
        /// </summary>
        /// <param name="httpClient">The <see cref="HttpClient"/> (where overridding the default value).</param>
        /// <param name="beforeRequest">The <see cref="Action{HttpRequestMessage}"/> to invoke before the <see cref="HttpRequestMessage">Http Request</see> is made (see <see cref="WebApiServiceAgentBase.BeforeRequest"/>).</param>
        public ReferenceDataAgentProvider(HttpClient httpClient = null, Action<HttpRequestMessage> beforeRequest = null)
        {
            _agent = new ReferenceDataAgent(httpClient, beforeRequest);

]]>
  <Entity Condition="Entity.RefDataType != null and Entity.Abstract == false and Entity.EntityScope == 'Common'">
    <![CDATA[            _cacheDict.Add(typeof({{Entity.EntityName}}), new ]]>
    <If Condition="Config.RefDataCache == null">
      <Then><![CDATA[ReferenceDataCache]]></Then>
      <Else><![CDATA[{{Config.RefDataCache}}]]></Else>
    </If>
    <![CDATA[<{{Entity.EntityCollectionName}}, {{Entity.EntityName}}>(() => _agent.{{Entity.Name}}GetAllAsync().ContinueWith((t) => t.Result.Value)));
]]>
  </Entity>
  <![CDATA[        }

        #endregion

        #region Collections

]]>
  <Entity Condition="Entity.RefDataType != null and Entity.Abstract == false  and Entity.EntityScope == 'Common'">
    <![CDATA[        /// <summary> 
        /// Gets the {{Entity.EntityCollectionName:ToSeeComments}}.
        /// </summary>
        /// <returns>The {{Entity.EntityCollectionName:ToSeeComments}}.</returns>
        public override {{Entity.EntityCollectionName}} {{Entity.Name}} => ({{Entity.EntityCollectionName}})this[typeof({{Entity.EntityName}})];

]]>
  </Entity>
  <![CDATA[        #endregion
  
        #region This/GetCache/PrefetchAsync
    
        /// <summary>
        /// Gets the <see cref="IReferenceDataCollection"/> for the associated <see cref="ReferenceDataBase"/> <see cref="Type"/>.
        /// </summary>
        /// <param name="type">The <see cref="ReferenceDataBase"/> <see cref="Type"/>.</param>
        /// <returns>The <see cref="IReferenceDataCollection"/>.</returns>
        public override IReferenceDataCollection this[Type type] => GetCache(type).GetCollection();

        /// <summary>
        /// Gets the <see cref="IReferenceDataCache"/> for the associated <see cref="ReferenceDataBase"/> <see cref="Type"/>.
        /// </summary>
        /// <param name="type">The <see cref="ReferenceDataBase"/> <see cref="Type"/>.</param>
        /// <returns>The <see cref="IReferenceDataCache"/>.</returns>
        public IReferenceDataCache GetCache(Type type)
        {
            if (!_cacheDict.ContainsKey(Beef.Check.NotNull(type, nameof(type))))
                throw new ArgumentException(string.Format("Type {0} does not exist within the ReferenceDataProvider cache.", type.Name));

            return (IReferenceDataCache)_cacheDict[type];
        }
        
        /// <summary>
        /// Prefetches all of the named <see cref="ReferenceDataBase"/> objects where not already cached or have expired.
        /// </summary>
        /// <param name="names">The list of <see cref="ReferenceDataBase"/> type names.</param>
        public override async Task PrefetchAsync(params string[] names)
        {
            if (names == null || names.Length == 0)
                return;

            var getNames = new List<string>();
            if (names.Length == 1 && names[0] == ReferenceDataAgent.GetNamedAllNames)
                getNames.Add(ReferenceDataAgent.GetNamedAllNames);
            else
            {
                foreach (string name in names.Distinct())
                {
                    if (_nameDict.ContainsKey(name) && GetCache(_nameDict[name]).IsExpired)
                        getNames.Add(name);
                }
            }

            if (getNames.Count == 0)
                return;
                        
            var result = await _agent.GetNamedAsync(getNames.ToArray());
            foreach (var rdj in JObject.Parse("{ \"content\":" + result.Content + "}")["content"].Children())
            {
                switch (rdj["name"].Value<string>())
                {
]]>
  <Entity Condition="Entity.RefDataType != null and Entity.Abstract == false and Entity.EntityScope == 'Common'">
    <![CDATA[                    case Property_{{Entity.Name}}: GetCache(_nameDict[ReferenceData.Property_{{Entity.Name}}]).SetCollection(JsonConvert.DeserializeObject<{{Entity.Name}}[]>(rdj["items"].ToString())); break;
]]>
  </Entity>
  <![CDATA[                }
            }
        }
        
        #endregion
    }
}]]>
</Template>