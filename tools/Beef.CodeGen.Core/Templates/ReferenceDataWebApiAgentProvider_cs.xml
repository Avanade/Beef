<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright (c) Avanade. Licensed under the MIT License. See https://github.com/Avanade/Beef -->
<Template OutputGenDirName="Generated" OutputFileName="ReferenceDataAgentProvider.cs">
  <Set Name="System.ServiceClientName" Value="Config.WebApiServiceClient"/>
  <If Condition="System.ServiceClientName == null or System.ServiceClientName == ''">
    <Set Name="System.ServiceClientName" Value="'ServiceClient'"/>
  </If>
  <![CDATA[/*
 * This file is automatically generated; any changes will be lost. 
 */

#nullable enable
#pragma warning disable IDE0005 // Using directive is unnecessary; are required depending on code-gen options

using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Threading.Tasks;
using Beef.RefData;
using Beef.RefData.Caching;
using Beef.WebApi;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using {{Config.Company}}.{{Config.AppName}}.Common.Entities;
]]>
  <If Condition="Config.RefDataNamespace != null">
    <![CDATA[using RefDataNamespace = {{Config.RefDataNamespace}};
]]>
  </If>
  <![CDATA[
namespace {{Config.Company}}.{{Config.AppName}}.Common.Agents
{
    /// <summary>
    /// Provides the <see cref="ReferenceData"/> implementation using the corresponding Web API agent.
    /// </summary>
    public class ReferenceDataAgentProvider : ]]><If Condition="Config.RefDataNamespace != null"><![CDATA[RefDataNamespace.]]></If><![CDATA[ReferenceData
    {
        private readonly Dictionary<string, Type> _nameDict = new Dictionary<string, Type>();
        private readonly Dictionary<Type, string> _typeDict = new Dictionary<Type, string>();
        private readonly IReferenceDataAgent _agent;
        private readonly Dictionary<Type, object> _cacheDict = new Dictionary<Type, object>();

        #region Ctor
        
        /// <summary>
        /// Initializes a new instance of the <see cref="ReferenceDataAgentProvider"/> class.
        /// </summary>
        /// <param name="agent">The <see cref="IReferenceDataAgent"/>.</param>
        public ReferenceDataAgentProvider(IReferenceDataAgent agent)
        {
            _agent = Check.NotNull(agent, nameof(agent));

]]>
  <Entity Condition="Entity.RefDataType != null and Entity.Abstract == false and Entity.EntityScope == 'Common'">
    <Set Name="Entity.EntityName" Condition="Config.RefDataNamespace == null" Value="${{Entity.Name}}" Otherwise="$RefDataNamespace.{{Entity.Name}}" />
    <Set Name="Entity.EntityCollectionName" Condition="Config.RefDataNamespace == null" Value="${{Entity.Name}}Collection" Otherwise="$RefDataNamespace.{{Entity.Name}}Collection" />
    <If Condition="System.Index > 0">
      <![CDATA[
]]>
    </If>
    <![CDATA[            _nameDict.Add(nameof({{Entity.Name}}), typeof({{Entity.EntityName}}));
            _typeDict.Add(typeof({{Entity.EntityName}}), nameof({{Entity.Name}}));
            _cacheDict.Add(typeof({{Entity.EntityName}}), new ]]>
    <If Condition="Config.RefDataCache == null">
      <Then><![CDATA[ReferenceDataCache]]></Then>
      <Else><![CDATA[{{Config.RefDataCache}}]]></Else>
    </If>
    <![CDATA[<{{Entity.EntityCollectionName}}, {{Entity.EntityName}}>(() => _agent.{{Entity.Name}}GetAllAsync().ContinueWith((t) => t.Result.Value, TaskScheduler.Current)));
]]>
  </Entity>
  <![CDATA[
        }

        #endregion

        #region Collections

]]>
  <Entity Condition="Entity.RefDataType != null and Entity.Abstract == false  and Entity.EntityScope == 'Common'">
    <![CDATA[        /// <summary> 
        /// Gets the {{Entity.EntityCollectionName:ToSeeComments}}.
        /// </summary>
        /// <returns>The {{Entity.EntityCollectionName:ToSeeComments}}.</returns>
        public override {{Entity.EntityCollectionName}} {{Entity.Name}} => ({{Entity.EntityCollectionName}})this[typeof({{Entity.EntityName}})];

]]>
  </Entity>
  <![CDATA[        #endregion
  
        #region This/GetCache/PrefetchAsync
    
        /// <summary>
        /// Gets the <see cref="IReferenceDataCollection"/> for the associated <see cref="ReferenceDataBase"/> <see cref="Type"/>.
        /// </summary>
        /// <param name="type">The <see cref="ReferenceDataBase"/> <see cref="Type"/>.</param>
        /// <returns>The <see cref="IReferenceDataCollection"/>.</returns>
        public override IReferenceDataCollection this[Type type] => GetCache(type).GetCollection();

        /// <summary>
        /// Gets the <see cref="IReferenceDataCache"/> for the associated <see cref="ReferenceDataBase"/> <see cref="Type"/>.
        /// </summary>
        /// <param name="type">The <see cref="ReferenceDataBase"/> <see cref="Type"/>.</param>
        /// <returns>The <see cref="IReferenceDataCache"/>.</returns>
        public IReferenceDataCache GetCache(Type type)
        {
            if (type == null)
                throw new ArgumentNullException(nameof(type));
        
            if (!_cacheDict.ContainsKey(type))
                throw new ArgumentException($"Type {type.Name} does not exist within the ReferenceDataProvider cache.");

            return (IReferenceDataCache)_cacheDict[type];
        }
        
        /// <summary>
        /// Prefetches all of the named <see cref="ReferenceDataBase"/> objects where not already cached or have expired.
        /// </summary>
        /// <param name="names">The list of <see cref="ReferenceDataBase"/> type names.</param>
        public override async Task PrefetchAsync(params string[] names)
        {
            if (names == null || names.Length == 0)
                return;

            var getNames = new List<string>();
            foreach (string name in names.Distinct())
            {
                if (_nameDict.ContainsKey(name) && GetCache(_nameDict[name]).IsExpired)
                    getNames.Add(name);
            }

            if (getNames.Count == 0)
                return;
                        
            var result = await _agent.GetNamedAsync(getNames.ToArray()).ConfigureAwait(false);
            foreach (var rdj in JObject.Parse("{ \"content\": " + result.Content ?? "[ ]" + " }")["content"]!.Children())
            {
                var name = rdj["name"]?.Value<string>();
                var items = rdj["items"]?.ToString();
                if (name != null)
                {
                    switch (name)
                    {
]]>
  <Entity Condition="Entity.RefDataType != null and Entity.Abstract == false and Entity.EntityScope == 'Common'">
    <![CDATA[                        case nameof({{Entity.Name}}): GetCache(_nameDict[nameof({{Entity.Name}})]).SetCollection(JsonConvert.DeserializeObject<{{Entity.EntityName}}[]>(items!)); break;
]]>
  </Entity>
  <![CDATA[                    }
                 }
            }
        }
        
        #endregion
    }
}

#pragma warning restore IDE0005
#nullable restore]]>
</Template>