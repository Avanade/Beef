// Copyright (c) Avanade. Licensed under the MIT License. See https://github.com/Avanade/Beef

using Newtonsoft.Json;
using OnRamp;
using OnRamp.Config;
using OnRamp.Utility;
using System;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Beef.CodeGen.Config.Entity
{
    /// <summary>
    /// Represents the <b>Property</b> code-generation configuration.
    /// </summary>
    [CodeGenClass("Property", Title = "'Property' object (entity-driven)",
        Description = "The `Property` object defines an `Entity` property and its charateristics.",
        ExampleMarkdown = @"A YAML configuration [example](../samples/My.Hr/My.Hr.CodeGen/entity.beef.yaml) is as follows:
``` yaml
properties: [
  { name: Id, type: Guid, text: '{{Employee}} identifier', primaryKey: true, dataName: EmployeeId, dataAutoGenerated: true },
  { name: FirstName, type: string },
  { name: LastName, type: string },
  { name: Gender, type: RefDataNamespace.Gender, dataName: GenderCode },
  { name: Birthday, type: DateTime, dateTimeTransform: DateOnly },
  { name: ETag, type: string },
  { name: ChangeLog, type: ChangeLog }
]
```")]
    [CodeGenCategory("Key", Title = "Provides the _key_ configuration.")]
    [CodeGenCategory("Property", Title = "Provides additional _Property_ configuration.")]
    [CodeGenCategory("RefData", Title = "Provides the _Reference Data_ configuration.")]
    [CodeGenCategory("Serialization", Title = "Provides the _Serialization_ configuration.")]
    [CodeGenCategory("Data", Title = "Provides the generic _Data-layer_ configuration.")]
    [CodeGenCategory("Database", Title = "Provides the specific _Database (ADO.NET)_ configuration where `Entity.AutoImplement` or `Operation.AutoImplement` is `Database`.")]
    [CodeGenCategory("EntityFramework", Title = "Provides the specific _Entity Framework (EF)_ configuration where `Entity.AutoImplement` or `Operation.AutoImplement` is `EntityFramework`.")]
    [CodeGenCategory("Cosmos", Title = "Provides the specific _Cosmos DB_ configuration where `Entity.AutoImplement` or `Operation.AutoImplement` is `Cosmos`.")]
    [CodeGenCategory("OData", Title = "Provides the specific _OData_ configuration where `Entity.AutoImplement` or `Operation.AutoImplement` is `OData`.")]
    [CodeGenCategory("HttpAgent", Title = "Provides the specific _HTTP Agent_ configuration where `Entity.AutoImplement` or `Operation.AutoImplement` is `HttpAgent`.")]
    [CodeGenCategory("Annotation", Title = "Provides additional property _Annotation_ configuration.")]
    [CodeGenCategory("gRPC", Title = "Provides the _gRPC_ configuration.")]
    public class PropertyConfig : ConfigBase<CodeGenConfig, EntityConfig>
    {
        /// <summary>
        /// <inheritdoc/>
        /// </summary>
        /// <remarks><inheritdoc/></remarks>
        public override string? QualifiedKeyName => BuildQualifiedKeyName("Property", Name);

        #region Key

        /// <summary>
        /// Gets or sets the unique property name.
        /// </summary>
        [JsonProperty("name", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Key", Title = "The unique property name.", IsMandatory = true, IsImportant = true)]
        public string? Name { get; set; }

        /// <summary>
        /// Gets or sets the overriding text for use in comments.
        /// </summary>
        [JsonProperty("text", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Key", Title = "The overriding text for use in comments.",
            Description = "By default the `Text` will be the `Name` reformatted as sentence casing. Depending on whether the `Type` is `bool`, will appear in one of the two generated sentences. Where not `bool` it will be: Gets or sets a value indicating whether {text}.'. " +
            "Otherwise, it will be: Gets or sets the {text}.'. To create a `<see cref=\"XXX\"/>` within use moustache shorthand (e.g. {{Xxx}}).")]
        public string? Text { get; set; }

        /// <summary>
        /// Gets or sets the overriding model text for use in comments.
        /// </summary>
        [JsonProperty("modelText", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Key", Title = "The overriding model text for use in comments.",
            Description = "By default the `ModelText` will be the `Name` reformatted as sentence casing. Depending on whether the `Type` is `bool`, will appear in one of the two generated sentences. Where not `bool` it will be: Gets or sets a value indicating whether {text}.'. " +
            "Otherwise, it will be: Gets or sets the {text}.'. To create a `<see cref=\"XXX\"/>` within use moustache shorthand (e.g. {{Xxx}}).")]
        public string? ModelText { get; set; }

        /// <summary>
        /// Gets or sets the .NET <see cref="Type"/>.
        /// </summary>
        [JsonProperty("type", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Key", Title = "The .NET `Type`.", IsImportant = true,
            Description = "Defaults to `string`. To reference a Reference Data `Type` always prefix with `RefDataNamespace` (e.g. `RefDataNamespace.Gender`) or shortcut `^` (e.g. `^Gender`). This will ensure that the appropriate Reference Data " +
            "`using` statement is used. _Shortcut:_ Where the `Type` starts with (prefix) `RefDataNamespace.` or `^`, and the correspondong `RefDataType` attribute is not specified it will automatically default the `RefDataType` to `string.`")]
        public string? Type { get; set; }

        /// <summary>
        /// Indicates whether the .NET <see cref="Type"/> should be declared as nullable.
        /// </summary>
        [JsonProperty("nullable", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Key", Title = "Indicates whether the .NET `Type` should be declared as nullable; e.g. `string?`. Will be inferred where the `Type` is denoted as nullable; i.e. suffixed by a `?`.", IsImportant = true)]
        public bool? Nullable { get; set; }

        /// <summary>
        /// Indicates whether the property is inherited and therefore should not be output within the generated Entity class.
        /// </summary>
        [JsonProperty("inherited", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Key", Title = "Indicates whether the property is inherited and therefore should not be output within the generated Entity class.")]
        public bool? Inherited { get; set; }

        /// <summary>
        /// Gets or sets the overriding private name.
        /// </summary>
        [JsonProperty("privateName", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Key", Title = "The overriding private name.",
            Description = "Overrides the `Name` to be used for private fields. By default reformatted from `Name`; e.g. `FirstName` as `_firstName`.")]
        public string? PrivateName { get; set; }

        /// <summary>
        /// Gets or sets the overriding argument name.
        /// </summary>
        [JsonProperty("argumentName", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Key", Title = "The overriding argument name.",
            Description = "Overrides the `Name` to be used for argument parameters. By default reformatted from `Name`; e.g. `FirstName` as `firstName`.")]
        public string? ArgumentName { get; set; }

        #endregion

        #region Property

        /// <summary>
        /// Indicates whether the property is considered part of the primary (unique) key.
        /// </summary>
        [JsonProperty("primaryKey", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Property", Title = "Indicates whether the property is considered part of the primary (unique) key.", IsImportant = true,
            Description = "This is also used to simplify the parameter specification for an Entity Operation by inferrence.")]
        public bool? PrimaryKey { get; set; }

        /// <summary>
        /// Indicates that the property Type is another generated entity / collection and therefore specific capabilities can be assumed (e.g. CopyFrom and Clone).
        /// </summary>
        [JsonProperty("isEntity", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Property", Title = "Indicates that the property `Type` is another generated entity / collection and therefore specific capabilities can be assumed (e.g. `CopyFrom` and `Clone`).", IsImportant = true,
            Description = "Will be inferred (default to `true`) where the `Type` is `ChangeLog` or the `Type` is found as another `Entity` within the code-generation configuration file.")]
        public bool? IsEntity { get; set; }

        /// <summary>
        /// Indicates that the value is immutable and therefore cannot be changed once set.
        /// </summary>
        [JsonProperty("immutable", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Property", Title = "Indicates that the value is immutable and therefore cannot be changed once set.")]
        public bool? Immutable { get; set; }

        /// <summary>
        /// Gets or sets the <see cref="DateTime"/> transformation to be performed on <c>Set</c> and <c>CleanUp</c>.
        /// </summary>
        [JsonProperty("dateTimeTransform", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Property", Title = "The `DateTime` transformation to be performed on `Set` and `CleanUp`.", Options = new string[] { "UseDefault", "None", "DateOnly", "DateTimeLocal", "DateTimeUtc", "DateTimeUnspecified" },
            Description = "Defaults to `UseDefault`. This is only applied where the `Type` is `DateTime`.")]
        public string? DateTimeTransform { get; set; }

        /// <summary>
        /// Gets or sets the <see cref="string"/> trimming of white space characters to be performed on <c>Set</c> and <c>CleanUp</c>.
        /// </summary>
        [JsonProperty("stringTrim", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Property", Title = "The `string` trimming of white space characters to be performed on `Set` and `CleanUp`.", Options = new string[] { "UseDefault", "None", "Start", "End", "Both" },
            Description = "Defaults to `UseDefault`. This is only applied where the `Type` is `string`.")]
        public string? StringTrim { get; set; }

        /// <summary>
        /// Gets or sets the <see cref="string"/> transformation to be performed on <c>Set</c> and <c>CleanUp</c>.
        /// </summary>
        [JsonProperty("stringTransform", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Property", Title = "The `string` transformation to be performed on `Set` and `CleanUp`.", Options = new string[] { "UseDefault", "None", "NullToEmpty", "EmptyToNull" },
            Description = "Defaults to `UseDefault`. This is only applied where the `Type` is `string`.")]
        public string? StringTransform { get; set; }

        /// <summary>
        /// Gets or sets the <see cref="string"/> casing to be performed on <c>Set</c> and <c>CleanUp</c>.
        /// </summary>
        [JsonProperty("stringCasing", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Property", Title = "The `string` casing to be performed on `Set` and `CleanUp`.", Options = new string[] { "UseDefault", "None", "Lower", "Upper", "Title" },
            Description = "Defaults to `UseDefault`. This is only applied where the `Type` is `string`.")]
        public string? StringCasing { get; set; }

        /// <summary>
        /// Indicates whether an instance of the <see cref="Type"/> is to be automatically created/instantiated when the property is first accessed (i.e. lazy instantiation).
        /// </summary>
        [JsonProperty("autoCreate", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Property", Title = "Indicates whether an instance of the `Type` is to be automatically created/instantiated when the property is first accessed (i.e. lazy instantiation).")]
        public bool? AutoCreate { get; set; }

        /// <summary>
        /// Gets or sets the C# code to default the value.
        /// </summary>
        [JsonProperty("default", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Property", Title = "The C# code to default the value.",
            Description = "Where the `Type` is `string` then the specified default value will need to be delimited. Any valid value assignment C# code can be used.")]
        public string? Default { get; set; }

        /// <summary>
        /// Indicates whether the property is considered part of the Partition Key.
        /// </summary>
        [JsonProperty("partitionKey", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Property", Title = "Indicates whether the property is considered part of the Partition Key.",
            Description = "This will implement `IPartitionKey` for the generated entity.")]
        public bool? PartitionKey { get; set; }

        /// <summary>
        /// Indicates whether the property is for internal use only; declared in the Business entities only.
        /// </summary>
        [JsonProperty("internalOnly", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Property", Title = "Indicates whether the property is for internal use only; declared in Business entities only.",
            Description = "In this instance the `Property` will be excluded from the `Common` entity declaration and `Business` JSON serialization.")]
        public bool? InternalOnly { get; set; }

        #endregion

        #region RefData

        /// <summary>
        /// Gets or sets the underlying Reference Data Type that is also used as the Reference Data serialization identifier (SID).
        /// </summary>
        [JsonProperty("refDataType", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("RefData", Title = "The underlying Reference Data Type that is also used as the Reference Data serialization identifier (SID).", Options = new string[] { "string", "int", "Guid" },
            Description = "Defaults to `string` (being the `ReferenceDataBase.Code`) where not specified and the corresponding `Type` starts with (prefix) `RefDataNamespace.` or `^`. Note: an `Id` of type `string` is currently not supported; the use of the `Code` is the recommended approach.")]
        public string? RefDataType { get; set; }

        /// <summary>
        /// Indicates that the Reference Data property is to be a serializable list (ReferenceDataSidList). 
        /// </summary>
        [JsonProperty("refDataList", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("RefData", Title = "Indicates that the Reference Data property is to be a serializable list (`ReferenceDataSidList`).",
            Description = "This is required to enable a list of Reference Data values (as per `RefDataType`) to be passed as an argument for example.")]
        public bool? RefDataList { get; set; }

        /// <summary>
        /// Indicates whether a corresponding <i>text</i> property is added when generating a Reference Data property overriding the <c>CodeGeneration.RefDataText</c> selection.
        /// </summary>
        [JsonProperty("refDataText", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("RefData", Title = "Indicates whether a corresponding `Text` property is added when generating a Reference Data property, overriding the `Entity.RefDataText` selection.", Options = new string[] { "Optional", "Always", "Never" },
            Description = "This is used where serializing within the Web API `Controller` and the `ExecutionContext.IsRefDataTextSerializationEnabled` is set to `true` (which is automatically set where the url contains `$text=true`)." +
                          "`Optional` indicates when `ExecutionContext.IsRefDataTextSerializationEnabled` is set to `true` then a value is output, `Always` indicates that the value is _always_ output, and `Never` indicates that feature is turned off.")]
        public string? RefDataText { get; set; }

        /// <summary>
        /// Gets or sets the corresponding <i>text</i> property name.
        /// </summary>
        [JsonProperty("refDataTextName", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("RefData", Title = "The corresponding reference data `Text` property name; defaults to `Name` + 'Text'.")]
        public string? RefDataTextName { get; set; }

        /// <summary>
        /// Indicates whether the property should use the underlying Reference Data mapping capabilities. 
        /// </summary>
        [JsonProperty("refDataMapping", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("RefData", Title = "Indicates whether the property should use the underlying Reference Data mapping capabilities.",
            Description = "Mapped properties are a special Reference Data property type that ensure value uniqueness; this allows the likes of additional to/from mappings to occur between systems where applicable.")]
        public bool? RefDataMapping { get; set; }

        #endregion

        #region Serialization

        /// <summary>
        /// Gets or sets the JSON property name.
        /// </summary>
        [JsonProperty("jsonName", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Serialization", Title = "The JSON property name.",
            Description = "Defaults to `ArgumentName` where not specified (i.e. camelCase); however, where the property is `ETag` it will default to the `Config.ETagJsonName`.")]
        public string? JsonName { get; set; }

        /// <summary>
        /// Gets or sets the JSON property name for the corresponding data model.
        /// </summary>
        [JsonProperty("jsonDataModelName", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Serialization", Title = "The JSON property name for the corresponding data model (see `Entity.DataModel`).",
            Description = "Defaults to `JsonName` where not specified.")]
        public string? JsonDataModelName { get; set; }

        /// <summary>
        /// Indicates whether the property is not to be serialized.
        /// </summary>
        [JsonProperty("serializationIgnore", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Serialization", Title = "Indicates whether the property is not to be serialized.",
            Description = "All properties are serialized by default.")]
        public bool? SerializationIgnore { get; set; }

        /// <summary>
        /// Indicates whether to always include the value (default or otherwise) when serializing.
        /// </summary>
        [JsonProperty("serializationAlwaysInclude", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Serialization", Title = "Indicates whether to include the value (default or otherwise) when serializing.")]
        public bool? SerializationAlwaysInclude { get; set; }

        /// <summary>
        /// Indicates whether the property is not to be serialized.
        /// </summary>
        [JsonProperty("dataModelIgnore", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Serialization", Title = "Indicates whether the property is to be included within the data model.",
            Description = "All properties are included in the data model by default.")]
        public bool? DataModelIgnore { get; set; }

        /// <summary>
        /// Indicates whether the property is not to be serialized where outputting as a data model.
        /// </summary>
        [JsonProperty("dataModelSerializationIgnore", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Serialization", Title = "Indicates whether the property is not to be serialized where outputting as a data model.",
            Description = "All properties are included in the data model by default.")]
        public bool? DataModelSerializationIgnore { get; set; }

        #endregion

        #region Data

        /// <summary>
        /// Gets or sets the data name where `Entity.AutoImplement` is selected.
        /// </summary>
        [JsonProperty("dataName", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Data", Title = "The data name where Entity.AutoImplement is selected.", IsImportant = true,
            Description = "Defaults to the property `Name`. Represents the column name for a `Database`, or the correspinding property name for the other options.")]
        public string? DataName { get; set; }

        /// <summary>
        /// Gets or sets the data `Converter` class name where `Entity.AutoImplement` is selected.
        /// </summary>
        [JsonProperty("dataConverter", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Data", Title = "The data `Converter` class name where `Entity.AutoImplement` is selected.", IsImportant = true,
            Description = "A `Converter` is used to convert a data source value to/from a .NET `Type` where no standard data conversion can be applied. Where this value is suffixed by `<T>` or `{T}` this will automatically set `Type`.")]
        public string? DataConverter { get; set; }

        /// <summary>
        /// Indicates whether the property should be ignored (excluded) from the Data / DataMapper generated output. 
        /// </summary>
        [JsonProperty("dataMapperIgnore", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Data", Title = "Indicates whether the property should be ignored (excluded) from the `Data`-layer / data `Mapper` generated output.",
            Description = "All properties are included by default.")]
        public bool? DataMapperIgnore { get; set; }

        /// <summary>
        /// Indicates whether the `PrimaryKey` property value is automatically generated by the data source on `Create`.
        /// </summary>
        [JsonProperty("dataAutoGenerated", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Data", Title = "Indicates whether the `PrimaryKey` property value is automatically generated by the data source on `Create`.")]
        public bool? DataAutoGenerated { get; set; }

        /// <summary>
        /// Gets or sets the operations types (`ExecutionContext.OperationType`) selection to enable inclusion and exclusion of property mapping.
        /// </summary>
        [JsonProperty("dataOperationTypes", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Data", Title = "The operations types (`ExecutionContext.OperationType`) selection to enable inclusion and exclusion of property mapping.",
            Options = new string[] { "Any", "AnyExceptCreate", "AnyExceptUpdate", "AnyExceptGet", "Get", "Create", "Update", "Delete" },
            Description = "Defaults to `Any`.")]
        public string? DataOperationTypes { get; set; }

        #endregion

        #region Database

        /// <summary>
        /// Gets or sets the database property `Mapper` class name where `Entity.AutoImplement` is selected.
        /// </summary>
        [JsonProperty("databaseMapper", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Database", Title = "The database property `Mapper` class name where `Entity.AutoImplement` is selected.",
            Description = "A `Mapper` is used to map a data source value to/from a .NET complex `Type` (i.e. class with one or more properties).")]
        public string? DatabaseMapper { get; set; }

        /// <summary>
        /// Indicates whether the property should be ignored (excluded) from the database `Mapper` generated output.
        /// </summary>
        [JsonProperty("databaseIgnore", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Database", Title = "Indicates whether the property should be ignored (excluded) from the database `Mapper` generated output.")]
        public bool? DatabaseIgnore { get; set; }

        /// <summary>
        /// Gets or sets the database DbType override (versus inferring from the corresponding .NET Type).
        /// </summary>
        [JsonProperty("databaseDbType", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Database", Title = "The database `DbType` override (versus inferring from the corresponding .NET Type).", IsImportant = true,
            Description = "Overrides the inferred database type; i.e. can specify `Date` or `DateTime2`, for .NET Type `System.DateTime`.")]
        public string? DatabaseDbType { get; set; }

        #endregion

        #region EntityFramework

        /// <summary>
        /// The Entity Framework `Mapper` approach for the property.
        /// </summary>
        [JsonProperty("entityFrameworkMapper", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("EntityFramework", Title = "The Entity Framework `Mapper` approach for the property.", Options = new string[] { "Set", "Ignore", "Map", "Flatten" },
            Description = "Defaults to `Set`.")]
        public string? EntityFrameworkMapper { get; set; }

        #endregion

        #region Cosmos

        /// <summary>
        /// The Cosmos `Mapper` approach for the property.
        /// </summary>
        [JsonProperty("cosmosMapper", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Cosmos", Title = "The Cosmos `Mapper` approach for the property.", Options = new string[] { "Set", "Ignore", "Map", "Flatten" },
            Description = "Defaults to `Set`.")]
        public string? CosmosMapper { get; set; }

        #endregion

        #region OData

        /// <summary>
        /// The OData `Mapper` approach for the property.
        /// </summary>
        [JsonProperty("odataMapper", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("OData", Title = "The OData `Mapper` approach for the property.", Options = new string[] { "Map", "Ignore", "Skip" },
            Description = "Defaults to `Map` which indicates the property will be explicitly mapped. A value of `Ignore` will explicitly `Ignore`, whilst a value of `Skip` will skip code-generated mapping altogether.")]
        public string? ODataMapper { get; set; }

        #endregion

        #region HttpAgent

        /// <summary>
        /// The HttpAgent `Mapper` approach for the property.
        /// </summary>
        [JsonProperty("httpAgentMapper", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("HttpAgent", Title = "The HttpAgent `Mapper` approach for the property.", Options = new string[] { "Set", "Ignore", "Map", "Flatten" },
            Description = "Defaults to `Set`.")]
        public string? HttpAgentMapper { get; set; }

        #endregion

        #region Annotation

        /// <summary>
        /// Gets or sets the display name used in the likes of error messages for the property.
        /// </summary>
        [JsonProperty("displayName", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Annotation", Title = "The display name used in the likes of error messages for the property.",
            Description = "Defaults to the `Name` as sentence case.")]
        public string? DisplayName { get; set; }

        /// <summary>
        /// Gets or sets the property annotation (e.g. attribute) declaration code.
        /// </summary>
        [JsonProperty("annotation1", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Annotation", Title = "The property annotation (e.g. attribute) declaration code.")]
        public string? Annotation1 { get; set; }

        /// <summary>
        /// Gets or sets the property annotation (e.g. attribute) declaration code.
        /// </summary>
        [JsonProperty("annotation2", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Annotation", Title = "The property annotation (e.g. attribute) declaration code.")]
        public string? Annotation2 { get; set; }

        /// <summary>
        /// Gets or sets the property annotation (e.g. attribute) declaration code.
        /// </summary>
        [JsonProperty("annotation3", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("Annotation", Title = "The property annotation (e.g. attribute) declaration code.")]
        public string? Annotation3 { get; set; }

        #endregion

        #region Grpc

        /// <summary>
        /// Gets or sets the unique (immutable) field number required to enable gRPC support.
        /// </summary>
        [JsonProperty("grpcFieldNo", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("gRPC", Title = "The unique (immutable) field number required to enable gRPC support.", IsImportant = true)]
        public int? GrpcFieldNo { get; set; }

        /// <summary>
        /// Gets or sets the underlying gRPC data type.
        /// </summary>
        [JsonProperty("grpcType", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [CodeGenProperty("gRPC", Title = "The underlying gRPC data type; will be inferred where not specified.")]
        public string? GrpcType { get; set; }

        #endregion

        /// <summary>
        /// Gets the formatted summary text.
        /// </summary>
        public string? SummaryText => StringConverter.ToComments($"{(Type == "bool" ? "Indicates whether" : "Gets or sets the")} {Text}.");

        /// <summary>
        /// Gets the formatted model summary text.
        /// </summary>
        public string? ModelSummaryText => StringConverter.ToComments($"{(Type == "bool" ? "Indicates whether" : "Gets or sets the")} {ModelText}.");

        /// <summary>
        /// Gets the formatted summary text for the Reference Data Serialization Identifier (SID) property.
        /// </summary>
        public string? SummaryRefDataSid => CompareValue(RefDataList, true)
            ? StringConverter.ToComments($"Gets or sets the {{{{{Name}}}}} list using the underlying Serialization Identifier (SID).")
            : StringConverter.ToComments($"Gets or sets the {{{{{Name}}}}} using the underlying Serialization Identifier (SID).");

        /// <summary>
        /// Gets the formatted summary text for the Reference Data Text property.
        /// </summary>
        public string? SummaryRefDataText => StringConverter.ToComments($"Gets the corresponding {{{{{Name}}}}} text (read-only where selected).");

        /// <summary>
        /// Gets the formatted summary text when used in a parameter context.
        /// </summary>
        public string? ParameterSummaryText => StringConverter.ToComments($"{(Type == "bool" ? "Indicates whether" : "The")} {Text}.");

        /// <summary>
        /// Gets the <see cref="Name"/> formatted as see comments.
        /// </summary>
        public string? PropertyNameSeeComments => StringConverter.ToSeeComments(Name);

        /// <summary>
        /// Indicates whether the property is a ChangeLog (name and type).
        /// </summary>
        public bool IsChangeLog => Name == "ChangeLog" && (Type == "ChangeLog" || Type == "ChangeLogEx");

        /// <summary>
        /// Interim property type to make on-the-fly tweaks to the type.
        /// </summary>
        private string? InterimPropertyType => IsChangeLog ? "ChangeLogEx" : Type;

        /// <summary>
        /// Gets the computed declared property type.
        /// </summary>
        public string PropertyType => string.IsNullOrEmpty(RefDataType) 
            ? PrivateType 
            : (CompareValue(RefDataList, true) ? $"ReferenceDataCodeList<{Type}{(RefDataType == "string" ? "?" : "")}, {RefDataType}>?" : CompareValue(Nullable, true) ? InterimPropertyType + "?" : InterimPropertyType!);

        /// <summary>
        /// Gets the computed declared private type.
        /// </summary>
        public string PrivateType
        {
            get
            {
                if (string.IsNullOrEmpty(RefDataType))
                    return CompareValue(Nullable, true) ? InterimPropertyType + "?" : InterimPropertyType!;

                var rt = CompareValue(RefDataList, true) ? $"List<{RefDataType}{(RefDataType == "string" ? "?" : "")}>" : RefDataType!;
                return CompareValue(Nullable, true) ? rt + "?" : rt!;
            }
        }

        /// <summary>
        /// Gets the computed declared private type for a model.
        /// </summary>
        public string ModelType => IsChangeLog ? "ChangeLog?" : PrivateType;

        /// <summary>
        /// Gets or sets the declared type including nullability.
        /// </summary>
        public string? DeclaredType { get; set; }

        /// <summary>
        /// Gets the reference data database get value type.
        /// </summary>
        public string? RefDataGetValueType { get; set; }

        /// <summary>
        /// Gets the computed property name.
        /// </summary>
        public string PropertyName => string.IsNullOrEmpty(RefDataType) ? Name! : Name! + (CompareValue(RefDataList, true) ? "Sids" : "Sid");

        /// <summary>
        /// Gets the computed argument name.
        /// </summary>
        public string PropertyArgumentName => string.IsNullOrEmpty(RefDataType) ? ArgumentName! : ArgumentName! + (CompareValue(RefDataList, true) ? "Sids" : "Sid");

        /// <summary>
        /// Gets the computed private name.
        /// </summary>
        public string PropertyPrivateName => string.IsNullOrEmpty(RefDataType) ? PrivateName! : PrivateName! + (CompareValue(RefDataList, true) ? "Sids" : "Sid");

        /// <summary>
        /// Gets the computed data mapper property name.
        /// </summary>
        public string DataMapperPropertyName => string.IsNullOrEmpty(RefDataType) ? Name! : CompareNullOrValue(DataConverter, "ReferenceDataCodeConverter") ? PropertyName : Name!;

        /// <summary>
        /// Gets or sets the data converter name.
        /// </summary>
        public string? DataConverterName => string.IsNullOrEmpty(DataConverter) ? null : $"{DataConverter}.Default";

        /// <summary>
        /// Gets the data converter C# code.
        /// </summary>
        public string? DataConverterCode => string.IsNullOrEmpty(DataConverter) ? null : $".SetConverter({DataConverterName})";

        /// <summary>
        /// Gets or sets the data converter name.
        /// </summary>
        public string? MapperDataConverterName => string.IsNullOrEmpty(DataConverter) ? null : $"{DataConverter}.Default";

        /// <summary>
        /// Gets the data converter C# code.
        /// </summary>
        public string? MapperDataConverterCode => string.IsNullOrEmpty(DataConverter) ? null : $".SetConverter({MapperDataConverterName})";

        /// <summary>
        /// Gets the data converter C# code for reference data data access.
        /// </summary>
        public string? RefDataConverterCode => string.IsNullOrEmpty(DataConverter) ? null : $"{DataConverterName}.ToSource.Convert(";

        /// <summary>
        /// Gets the EntityFramework data mapper - entity to model code.
        /// </summary>
        public string? EntityFrameworkDataMapperToModelCode => EntityFrameworkMapper switch
        {
            "Set" => $"Map((s, d) => d.{DataName ?? Name} = {(MapperDataConverterName == null ? "" : $"{MapperDataConverterName}.ToDestination.Convert(")}s.{DataMapperPropertyName}{(MapperDataConverterName == null ? "" : ")")}, OperationTypes.{DataOperationTypes}, s => s.{DataMapperPropertyName} == default, d => d.{DataName ?? Name} = default);",
            "Map" => $"Map((o, s, d) => d.{DataName ?? Name} = o.Map(s.{DataMapperPropertyName}, d.{DataName ?? Name}), OperationTypes.{DataOperationTypes}, s => s.{DataMapperPropertyName} == default, d => d.{DataName ?? Name} = default);",
            "Flatten" => $"Flatten(s => s.{DataMapperPropertyName}, OperationTypes.{DataOperationTypes}, s => s.{DataMapperPropertyName} == default);",
            _ => "!! code-gen error !!"
        };

        /// <summary>
        /// Gets the EntityFramework data mapper - model to entity code.
        /// </summary>
        public string? EntityFrameworkDataMapperFromModelCode => EntityFrameworkMapper switch
        {
            "Set" => $"Map((s, d) => d.{DataMapperPropertyName} = ({PrivateType}){(MapperDataConverterName == null ? "" : $"{MapperDataConverterName}.ToSource.Convert(")}s.{DataName ?? Name}!{(MapperDataConverterName == null ? "" : ")")}, OperationTypes.{DataOperationTypes}, s => s.{DataName ?? Name} == default, d => d.{DataMapperPropertyName} = default);",
            "Map" => $"Map((o, s, d) => d.{DataMapperPropertyName} = o.Map(s.{DataName ?? Name}, d.{DataName ?? Name}), OperationTypes.{DataOperationTypes}, s => s.{DataName ?? Name} == default, d => d.{DataMapperPropertyName} = default);",
            "Flatten" => $"Expand<{(IsChangeLog ? "ChangeLogEx" : Type)}>((d, v) => d.{DataName ?? Name} = v, OperationTypes.{DataOperationTypes}, d => d.{DataName ?? Name} = default);",
            _ => "!! code-gen error !!"
        };

        /// <summary>
        /// Gets the Cosmos data mapper - entity to model code.
        /// </summary>
        public string? CosmosDataMapperToModelCode => CosmosMapper switch
        {
            "Set" => $"Map((s, d) => d.{DataName ?? Name} = {(MapperDataConverterName == null ? "" : $"{MapperDataConverterName}.ToDestination.Convert(")}s.{DataMapperPropertyName}{(MapperDataConverterName == null ? "" : ")")}, OperationTypes.{DataOperationTypes}, s => s.{DataMapperPropertyName} == default, d => d.{DataName ?? Name} = default);",
            "Map" => $"Map((o, s, d) => d.{DataName ?? Name} = o.Map(s.{DataMapperPropertyName}, d.{DataName ?? Name}), OperationTypes.{DataOperationTypes}, s => s.{DataMapperPropertyName} == default, d => d.{DataName ?? Name} = default);",
            "Flatten" => $"Flatten(s => s.{DataMapperPropertyName}, OperationTypes.{DataOperationTypes}, s => s.{DataMapperPropertyName} == default);",
            _ => "!! code-gen error !!"
        };

        /// <summary>
        /// Gets the Cosmos data mapper - model to entity code.
        /// </summary>
        public string? CosmosDataMapperFromModelCode => CosmosMapper switch
        {
            "Set" => $"Map((s, d) => d.{DataMapperPropertyName} = ({PrivateType}){(MapperDataConverterName == null ? "" : $"{MapperDataConverterName}.ToSource.Convert(")}s.{DataName ?? Name}!{(MapperDataConverterName == null ? "" : ")")}, OperationTypes.{DataOperationTypes}, s => s.{DataName ?? Name} == default, d => d.{DataMapperPropertyName} = default);",
            "Map" => $"Map((o, s, d) => d.{DataMapperPropertyName} = o.Map(s.{DataName ?? Name}, d.{DataName ?? Name}), OperationTypes.{DataOperationTypes}, s => s.{DataName ?? Name} == default, d => d.{DataMapperPropertyName} = default);",
            "Flatten" => $"Expand<{(IsChangeLog ? "ChangeLogEx" : Type)}>((d, v) => d.{DataName ?? Name} = v, OperationTypes.{DataOperationTypes}, d => d.{DataName ?? Name} = default);",
            _ => "!! code-gen error !!"
        };

        /// <summary>
        /// Gets the HttpAgent data mapper - entity to model code.
        /// </summary>
        public string? HttpAgentDataMapperToModelCode => HttpAgentMapper switch
        {
            "Set" => $"Map((s, d) => d.{DataName ?? Name} = {(MapperDataConverterName == null ? "" : $"{MapperDataConverterName}.ToDestination.Convert(")}s.{DataMapperPropertyName}{(MapperDataConverterName == null ? "" : ")")}, OperationTypes.{DataOperationTypes}, s => s.{DataMapperPropertyName} == default, d => d.{DataName ?? Name} = default);",
            "Map" => $"Map((o, s, d) => d.{DataName ?? Name} = o.Map(s.{DataMapperPropertyName}, d.{DataName ?? Name}), OperationTypes.{DataOperationTypes}, s => s.{DataMapperPropertyName} == default, d => d.{DataName ?? Name} = default);",
            "Flatten" => $"Flatten(s => s.{DataMapperPropertyName}, OperationTypes.{DataOperationTypes}, s => s.{DataMapperPropertyName} == default);",
            _ => "!! code-gen error !!"
        };

        /// <summary>
        /// Gets the HttpAgent data mapper - model to entity code.
        /// </summary>
        public string? HttpAgentDataMapperFromModelCode => HttpAgentMapper switch
        {
            "Set" => $"Map((s, d) => d.{DataMapperPropertyName} = ({PrivateType}){(MapperDataConverterName == null ? "" : $"{MapperDataConverterName}.ToSource.Convert(")}s.{DataName ?? Name}!{(MapperDataConverterName == null ? "" : ")")}, OperationTypes.{DataOperationTypes}, s => s.{DataName ?? Name} == default, d => d.{DataMapperPropertyName} = default);",
            "Map" => $"Map((o, s, d) => d.{DataMapperPropertyName} = o.Map(s.{DataName ?? Name}, d.{DataName ?? Name}), OperationTypes.{DataOperationTypes}, s => s.{DataName ?? Name} == default, d => d.{DataMapperPropertyName} = default);",
            "Flatten" => $"Expand<{(IsChangeLog ? "ChangeLogEx" : Type)}>((d, v) => d.{DataName ?? Name} = v, OperationTypes.{DataOperationTypes}, d => d.{DataName ?? Name} = default);",
            _ => "!! code-gen error !!"
        };

        /// <summary>
        /// Gets the WebAPI parameter type.
        /// </summary>
        public string WebApiParameterType => PrivateType;

        /// <summary>
        /// Indicates whether the property is to be set using the identifier generator on create.
        /// </summary>
        public bool IdentifierGenerator => CompareValue(Parent!.IdentifierGenerator, true) && Parent.HasIdentifier && CompareValue(PrimaryKey, true) && Name == "Id";

        /// <summary>
        /// Gets or sets the gRPC converter.
        /// </summary>
        public string? GrpcConverter { get; set; }

        /// <summary>
        /// Gets or sets the gRPC mapper.
        /// </summary>
        public string? GrpcMapper { get; set; }

        /// <summary>
        /// <inheritdoc/>
        /// </summary>
        protected override Task PrepareAsync()
        {
            Type = DefaultWhereNull(Type, () => "string");
            if (Type!.StartsWith("^"))
                Type = $"RefDataNamespace.{Type[1..]}";

            if (Type!.StartsWith("RefDataNamespace.", StringComparison.InvariantCulture))
                RefDataType = DefaultWhereNull(RefDataType, () => "string");

            if (RefDataType != null && !Type!.StartsWith("RefDataNamespace.", StringComparison.InvariantCulture))
                Type = $"RefDataNamespace.{Type}";

            if (Type!.EndsWith("?", StringComparison.InvariantCulture))
            {
                Type = Type[0..^1];
                Nullable = true;
            }

            DeclaredType = $"{Type}{(CompareValue(Nullable, true) ? "?" : "")}";
            RefDataGetValueType = DeclaredType;
            ModelText = StringConverter.ToComments(DefaultWhereNull(ModelText, () => Text ?? (Name == "Id" && PrimaryKey == true ? "identifier" : (StringConverter.ToSentenceCase(Name) + (RefDataType is null ? null : " code") + (RefDataList.HasValue && RefDataList.Value ? "(s)" : "")))));

            Text = StringConverter.ToComments(DefaultWhereNull(Text, () =>
            {
                if (Type!.StartsWith("RefDataNamespace.", StringComparison.InvariantCulture))
                    return $"{StringConverter.ToSentenceCase(Name)} (see {StringConverter.ToSeeComments(Type)})";

                if (Type == "ChangeLog")
                    return $"{StringConverter.ToSentenceCase(Name)} (see {StringConverter.ToSeeComments("CoreEx.Entities." + Type)})";

                var ent = Root!.Entities?.FirstOrDefault(x => x.Name == Type);
                if (ent != null)
                    return $"{StringConverter.ToSentenceCase(Name)} (see {StringConverter.ToSeeComments("Business.Entities." + Type)})";

                if (Name == "Id" && PrimaryKey == true)
                    return "{{" + Parent!.Name + "}} identifier";

                return StringConverter.ToSentenceCase(Name);
            }));

            PrivateName = DefaultWhereNull(PrivateName, () => StringConverter.ToPrivateCase(Name));
            ArgumentName = DefaultWhereNull(ArgumentName, () => StringConverter.ToCamelCase(Name));
            DateTimeTransform = DefaultWhereNull(DateTimeTransform, () => "UseDefault");
            StringTrim = DefaultWhereNull(StringTrim, () => "UseDefault");
            StringTransform = DefaultWhereNull(StringTransform, () => "UseDefault");
            StringCasing = DefaultWhereNull(StringCasing, () => "UseDefault");
            RefDataText = DefaultWhereNull(RefDataText, () => Parent!.RefDataText == true ? "Optional" : "Never");
            RefDataTextName = DefaultWhereNull(RefDataTextName, () => Name + "Text");
            Nullable = DefaultWhereNull(Nullable, () => !DotNet.IgnoreNullableTypes.Contains(Type!));
            JsonName = DefaultWhereNull(JsonName, () => Name == "ETag" ? Root!.ETagJsonName : null);
            JsonDataModelName = DefaultWhereNull(JsonDataModelName, () => JsonName);
            SerializationAlwaysInclude = DefaultWhereNull(SerializationAlwaysInclude, () => false);
            DataOperationTypes = DefaultWhereNull(DataOperationTypes, () => "Any");
            IsEntity = DefaultWhereNull(IsEntity, () => (Type == "ChangeLog" || Type == "ChangeLogEx" || Type.EndsWith("Collection") || Parent!.Parent!.Entities!.Any(x => x.Name == Type)) && RefDataType == null);
            Immutable = DefaultWhereNull(Immutable, () => RefDataMapping.HasValue && RefDataMapping.Value == true);

            if (CompareValue(InternalOnly, true))
                SerializationIgnore = true;

            DataName = DefaultWhereNull(DataName, () => (Name == "ETag" && (Parent!.AutoImplement == "Database" || Parent.AutoImplement == "EntityFramework")) ? "RowVersion" : null);
            DataConverter = DefaultWhereNull(DataConverter, () => string.IsNullOrEmpty(RefDataType) ? ((Name == "ETag" && (Parent!.AutoImplement == "Database" || Parent.AutoImplement == "EntityFramework")) ? Root!.ETagDefaultMapperConverter : "") : Root!.RefDataDefaultMapperConverter);
            var rdc = ReformatDataConverter(DataConverter, Type, RefDataType, RefDataGetValueType);
            DataConverter = rdc.DataConverter;
            RefDataGetValueType = rdc.RefDataGetValueType;

            EntityFrameworkMapper = DefaultWhereNull(EntityFrameworkMapper, () => CompareValue(IsEntity, true) ? "Flatten" : "Set");
            CosmosMapper = DefaultWhereNull(CosmosMapper, () => CompareValue(IsEntity, true) ? "Map" : "Set");
            ODataMapper = DefaultWhereNull(ODataMapper, () => CompareValue(IsEntity, true) ? "Map" : "Set");
            HttpAgentMapper = DefaultWhereNull(HttpAgentMapper, () => CompareValue(IsEntity, true) ? "Map" : "Set");

            GrpcType = DefaultWhereNull(GrpcType, () => InferGrpcType(string.IsNullOrEmpty(RefDataType) ? Type! : RefDataType!, RefDataType, RefDataList, DateTimeTransform));
            GrpcMapper = DotNet.SystemTypes.Contains(Type) || RefDataType != null ? null : Type;
            GrpcConverter = Type switch
            {
                "DateTime" => $"{(CompareValue(Nullable, true) ? "Nullable" : "")}{(DateTimeTransform == "DateOnly" ? "DateTimeToDateOnly" : "DateTimeToTimestamp")}",
                "Guid" => $"{(CompareValue(Nullable, true) ? "Nullable" : "")}GuidToStringConverter",
                "decimal" => $"{(CompareValue(Nullable, true) ? "Nullable" : "")}DecimalToDecimalConverter",
                _ => null
            };

            CheckDeprecatedProperties();

            return Task.CompletedTask;
        }

        /// <summary>
        /// Reformat the DataConverter and replace the Type placeholders.
        /// </summary>
        internal static (string? DataConverter, string? RefDataGetValueType) ReformatDataConverter(string? dataConverter, string type, string? refDataType, string? refDataGetValueType)
        {
            if (string.IsNullOrEmpty(dataConverter))
                return (dataConverter, refDataGetValueType);

            // Handle any legacy formatted values.
            dataConverter = dataConverter switch
            {
                "ReferenceDataCodeConverter" => "ReferenceDataCodeConverter<T>",
                "ReferenceDataCodeConverter{T}" => "ReferenceDataCodeConverter<T>",
                "ReferenceDataGuidIdConverter" => "ReferenceDataIdConverter<T, Guid>",
                "ReferenceDataInt32IdConverter" => "ReferenceDataIdConverter<T, int>",
                "ReferenceDataInt64IdConverter" => "ReferenceDataIdConverter<T, long>",
                "ReferenceDataStringIdConverter" => "ReferenceDataIdConverter<T, string?>",
                "ReferenceDataGuidIdConverter{T}" => "ReferenceDataIdConverter<T, Guid>",
                "ReferenceDataInt32IdConverter{T}" => "ReferenceDataIdConverter<T, int>",
                "ReferenceDataInt64IdConverter{T}" => "ReferenceDataIdConverter<T, long>",
                "ReferenceDataStringIdConverter{T}" => "ReferenceDataIdConverter<T, string?>",
                "ReferenceDataGuidIdConverter<T>" => "ReferenceDataIdConverter<T, Guid>",
                "ReferenceDataInt32IdConverter<T>" => "ReferenceDataIdConverter<T, int>",
                "ReferenceDataInt64IdConverter<T>" => "ReferenceDataIdConverter<T, long>",
                "ReferenceDataStringIdConverter<T>" => "ReferenceDataIdConverter<T, string?>",
                "ReferenceDataNullableGuidIdConverter" => "ReferenceDataIdConverter<T, Guid?>",
                "ReferenceDataNullableInt32IdConverter" => "ReferenceDataIdConverter<T, int?>",
                "ReferenceDataNullableInt64IdConverter" => "ReferenceDataIdConverter<T, long?>",
                "ReferenceDataNullableGuidIdConverter{T}" => "ReferenceDataIdConverter<T, Guid?>",
                "ReferenceDataNullableInt32IdConverter{T}" => "ReferenceDataIdConverter<T, int?>",
                "ReferenceDataNullableInt64IdConverter{T}" => "ReferenceDataIdConverter<T, long?>",
                "ReferenceDataNullableGuidIdConverter<T>" => "ReferenceDataIdConverter<T, Guid?>",
                "ReferenceDataNullableInt32IdConverter<T>" => "ReferenceDataIdConverter<T, int?>",
                "ReferenceDataNullableInt64IdConverter<T>" => "ReferenceDataIdConverter<T, long?>",
                _ => dataConverter
            };

            if (CompareValue(refDataType, "string") && CompareValue(dataConverter, "ReferenceDataCodeConverter<T>"))
                return (null, refDataGetValueType);

            var s = dataConverter.IndexOfAny(new char[] { '<', '{' });
            if (s < 1)
                return (dataConverter, refDataGetValueType);

            var e = dataConverter.IndexOfAny(new char[] { '>', '}' });
            if (e < 0 || e < s)
                return (dataConverter, refDataGetValueType);

            var parts = dataConverter.Substring(s + 1, e - s - 1).Split(',', StringSplitOptions.RemoveEmptyEntries);
            var sb = new StringBuilder();
            foreach (var part in parts)
            {
                var p = part.Trim();
                if (p.Length == 0)
                    continue;

                if (sb.Length > 0)
                    sb.Append(", ");

                switch (p)
                {
                    case "T": sb.Append(type); break;
                    case "T?": sb.Append($"{type}?"); break;
                    case "T2": sb.Append(refDataType); break;
                    case "T2?": sb.Append($"{refDataType}?"); break;
                    default: sb.Append(p); break;
                }

            }

            return ($"{dataConverter[..s]}<{sb}>", parts.Length > 1 ? parts[1].Trim() : refDataGetValueType);
        }

        /// <summary>
        /// Infers the gRPC data type.
        /// </summary>
        internal static string InferGrpcType(string type, string? refDataType = null, bool? refDataList = null, string? dateTimeTransform = null)
        {
            var gt = type switch
            {
                "string" => "google.protobuf.StringValue",
                "bool" => "google.protobuf.BoolValue",
                "double" => "google.protobuf.DoubleValue",
                "float" => "google.protobuf.FloatValue",
                "int" => "google.protobuf.Int32Value",
                "long" => "google.protobuf.Int64Value",
                "unit" => "google.protobuf.UInt32Value",
                "ulong" => "google.protobuf.UInt64Value",
                "short" => "google.protobuf.Int32Value",  // Not natively supported
                "ushort" => "google.protobuf.UInt32Value", // Not natively supported
                "Guid" => "google.protobuf.StringValue", // Not natively supported
                "byte[]" => "bytes", // Not natively supported
                "Decimal" => "Decimal", // Not natively supported
                "DateTime" => string.Compare(dateTimeTransform, "DateOnly", StringComparison.InvariantCulture) == 0 ? "DateOnly" : "google.protobuf.Timestamp", // DateOnly not natively supported
                "TimeSpan" => "google.protobuf.Duration",
                "void" => "google.protobuf.Empty",
                _ => type
            };

            return !string.IsNullOrEmpty(refDataType) && CompareValue(refDataList, true) ? "repeated " + gt : gt;
        }

        /// <summary>
        /// Check for any deprecate properties and error.
        /// </summary>
        private void CheckDeprecatedProperties()
        {
            if (ExtraProperties == null || ExtraProperties.Count == 0)
                return;

            var ep = ExtraProperties.Where(x => string.Compare(x.Key, "uniqueKey", StringComparison.InvariantCultureIgnoreCase) == 0).FirstOrDefault();
            if (ep.Key != null)
                throw new CodeGenException(this, ep.Key, $"The 'uniqueKey' configuration has been renamed to 'primaryKey'; please update the configuration accordingly.");

            ep = ExtraProperties.Where(x => string.Compare(x.Key, "serializationEmitDefault", StringComparison.InvariantCultureIgnoreCase) == 0).FirstOrDefault();
            if (ep.Key != null)
                throw new CodeGenException(this, ep.Key, $"The 'serializationEmitDefault' configuration has been renamed to 'serializationAlwaysInclude'; please update the configuration accordingly.");

            CodeGenConfig.WarnWhereDeprecated(Root!, this,
                "secondaryPropertyChanged",
                "bubblePropertyChanges",
                "excludeCleanup",
                "dataModelJsonName",
                "identifierGenerator",
                "dataConverterIsGeneric",
                "webApiQueryStringConverter");
        }
    }
}