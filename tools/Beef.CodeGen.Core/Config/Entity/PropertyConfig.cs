// Copyright (c) Avanade. Licensed under the MIT License. See https://github.com/Avanade/Beef

using Newtonsoft.Json;
using System;
using System.Linq;

namespace Beef.CodeGen.Config.Entity
{
    /// <summary>
    /// Represents the <b>Property</b> code-generation configuration.
    /// </summary>
    [ClassSchema("Property", Title = "'Property' object (entity-driven)",
        Description = "The `Property` object defines an `Entity` property and its charateristics.", 
        ExampleMarkdown = @"A YAML configuration [example](../samples/My.Hr/My.Hr.CodeGen/entity.beef.yaml) is as follows:
``` yaml
properties: [
  { name: Id, type: Guid, text: '{{Employee}} identifier', uniqueKey: true, dataName: EmployeeId, dataAutoGenerated: true },
  { name: FirstName, type: string },
  { name: LastName, type: string },
  { name: Gender, type: RefDataNamespace.Gender, dataName: GenderCode },
  { name: Birthday, type: DateTime, dateTimeTransform: DateOnly },
  { name: ETag, type: string },
  { name: ChangeLog, type: ChangeLog }
]
```")]
    [CategorySchema("Key", Title = "Provides the _key_ configuration.")]
    [CategorySchema("Property", Title = "Provides additional _Property_ configuration.")]
    [CategorySchema("RefData", Title = "Provides the _Reference Data_ configuration.")]
    [CategorySchema("Serialization", Title = "Provides the _Serialization_ configuration.")]
    [CategorySchema("Manager", Title = "Provides the _Manager-layer_ configuration.")]
    [CategorySchema("Data", Title = "Provides the generic _Data-layer_ configuration.")]
    [CategorySchema("Database", Title = "Provides the specific _Database (ADO.NET)_ configuration where `Entity.AutoImplement` or `Operation.AutoImplement` is `Database`.")]
    [CategorySchema("EntityFramework", Title = "Provides the specific _Entity Framework (EF)_ configuration where `Entity.AutoImplement` or `Operation.AutoImplement` is `EntityFramework`.")]
    [CategorySchema("Cosmos", Title = "Provides the specific _Cosmos DB_ configuration where `Entity.AutoImplement` or `Operation.AutoImplement` is `Cosmos`.")]
    [CategorySchema("OData", Title = "Provides the specific _OData_ configuration where `Entity.AutoImplement` or `Operation.AutoImplement` is `OData`.")]
    [CategorySchema("Annotation", Title = "Provides additional property _Annotation_ configuration.")]
    [CategorySchema("WebApi", Title = "Provides the data _Web API_ configuration.")]
    [CategorySchema("gRPC", Title = "Provides the _gRPC_ configuration.")]
    public class PropertyConfig : ConfigBase<CodeGenConfig, EntityConfig>
    {
        /// <summary>
        /// <inheritdoc/>
        /// </summary>
        /// <remarks><inheritdoc/></remarks>
        public override string? QualifiedKeyName => BuildQualifiedKeyName("Property", Name);

        #region Key

        /// <summary>
        /// Gets or sets the unique property name.
        /// </summary>
        [JsonProperty("name", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Key", Title = "The unique property name.", IsMandatory = true, IsImportant = true)]
        public string? Name { get; set; }

        /// <summary>
        /// Gets or sets the overriding text for use in comments.
        /// </summary>
        [JsonProperty("text", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Key", Title = "The overriding text for use in comments.",
            Description = "By default the `Text` will be the `Name` reformatted as sentence casing. Depending on whether the `Type` is `bool`, will appear in one of the two generated sentences. Where not `bool` it will be: Gets or sets a value indicating whether {text}.'. " +
            "Otherwise, it will be: Gets or sets the {text}.'. To create a `<see cref=\"XXX\"/>` within use moustache shorthand (e.g. {{Xxx}}).")]
        public string? Text { get; set; }

        /// <summary>
        /// Gets or sets the .NET <see cref="Type"/>.
        /// </summary>
        [JsonProperty("type", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Key", Title = "The .NET `Type`.", IsImportant = true,
            Description = "Defaults to `string`. To reference a Reference Data `Type` always prefix with `RefDataNamespace` (e.g. `RefDataNamespace.Gender`) or shortcut `^` (e.g. `^Gender`). This will ensure that the appropriate Reference Data " +
            "`using` statement is used. _Shortcut:_ Where the `Type` starts with (prefix) `RefDataNamespace.` or `^`, and the correspondong `RefDataType` attribute is not specified it will automatically default the `RefDataType` to `string.`")]
        public string? Type { get; set; }

        /// <summary>
        /// Indicates whether the .NET <see cref="Type"/> should be declared as nullable.
        /// </summary>
        [JsonProperty("nullable", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Key", Title = "Indicates whether the .NET `Type` should be declared as nullable; e.g. `string?`. Will be inferred where the `Type` is denoted as nullable; i.e. suffixed by a `?`.", IsImportant = true)]
        public bool? Nullable { get; set; }

        /// <summary>
        /// Indicates whether the property is inherited and therefore should not be output within the generated Entity class.
        /// </summary>
        [JsonProperty("inherited", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Key", Title = "Indicates whether the property is inherited and therefore should not be output within the generated Entity class.")]
        public bool? Inherited { get; set; }

        /// <summary>
        /// Gets or sets the overriding private name.
        /// </summary>
        [JsonProperty("privateName", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Key", Title = "The overriding private name.",
            Description = "Overrides the `Name` to be used for private fields. By default reformatted from `Name`; e.g. `FirstName` as `_firstName`.")]
        public string? PrivateName { get; set; }

        /// <summary>
        /// Gets or sets the overriding argument name.
        /// </summary>
        [JsonProperty("argumentName", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Key", Title = "The overriding argument name.",
            Description = "Overrides the `Name` to be used for argument parameters. By default reformatted from `Name`; e.g. `FirstName` as `firstName`.")]
        public string? ArgumentName { get; set; }

        #endregion

        #region Property

        /// <summary>
        /// Indicates whether the property is considered part of the unique (primary) key.
        /// </summary>
        [JsonProperty("uniqueKey", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Property", Title = "Indicates whether the property is considered part of the unique (primary) key.", IsImportant = true,
            Description = "This is also used to simplify the parameter specification for an Entity Operation by inferrence.")]
        public bool? UniqueKey { get; set; }

        /// <summary>
        /// Indicates that the property Type is another generated entity / collection and therefore specific capabilities can be assumed (e.g. CopyFrom and Clone).
        /// </summary>
        [JsonProperty("isEntity", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Property", Title = "Indicates that the property `Type` is another generated entity / collection and therefore specific capabilities can be assumed (e.g. `CopyFrom` and `Clone`).", IsImportant = true,
            Description = "Will be inferred (default to `true`) where the `Type` is `ChangeLog` or the `Type` is found as another `Entity` within the code-generation configuration file.")]
        public bool? IsEntity { get; set; }

        /// <summary>
        /// Indicates that the value is immutable and therefore cannot be changed once set.
        /// </summary>
        [JsonProperty("immutable", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Property", Title = "Indicates that the value is immutable and therefore cannot be changed once set.")]
        public bool? Immutable { get; set; }

        /// <summary>
        /// Gets or sets the <see cref="DateTime"/> transformation to be performed on <c>Set</c> and <c>CleanUp</c>.
        /// </summary>
        [JsonProperty("dateTimeTransform", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Property", Title = "The `DateTime` transformation to be performed on `Set` and `CleanUp`.", Options = new string[] { "UseDefault", "None", "DateOnly", "DateTimeLocal", "DateTimeUtc", "DateTimeUnspecified" },
            Description = "Defaults to `UseDefault`. This is only applied where the `Type` is `DateTime`.")]
        public string? DateTimeTransform { get; set; }

        /// <summary>
        /// Gets or sets the <see cref="string"/> trimming of white space characters to be performed on <c>Set</c> and <c>CleanUp</c>.
        /// </summary>
        [JsonProperty("stringTrim", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Property", Title = "The `string` trimming of white space characters to be performed on `Set` and `CleanUp`.", Options = new string[] { "UseDefault", "None", "Start", "End", "Both" },
            Description = "Defaults to `UseDefault`. This is only applied where the `Type` is `string`.")]
        public string? StringTrim { get; set; }

        /// <summary>
        /// Gets or sets the <see cref="string"/> transformation to be performed on <c>Set</c> and <c>CleanUp</c>.
        /// </summary>
        [JsonProperty("stringTransform", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Property", Title = "The `string` transformation to be performed on `Set` and `CleanUp`.", Options = new string[] { "UseDefault", "None", "NullToEmpty", "EmptyToNull" },
            Description = "Defaults to `UseDefault`. This is only applied where the `Type` is `string`.")]
        public string? StringTransform { get; set; }

        /// <summary>
        /// Indicates whether an instance of the <see cref="Type"/> is to be automatically created/instantiated when the property is first accessed (i.e. lazy instantiation).
        /// </summary>
        [JsonProperty("autoCreate", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Property", Title = "Indicates whether an instance of the `Type` is to be automatically created/instantiated when the property is first accessed (i.e. lazy instantiation).")]
        public bool? AutoCreate { get; set; }

        /// <summary>
        /// Gets or sets the C# code to default the value.
        /// </summary>
        [JsonProperty("default", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Property", Title = "The C# code to default the value.",
            Description = "Where the `Type` is `string` then the specified default value will need to be delimited. Any valid value assignment C# code can be used.")]
        public string? Default { get; set; }

        /// <summary>
        /// Indicates whether the property is considered part of the Partition Key.
        /// </summary>
        [JsonProperty("partitionKey", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Property", Title = "Indicates whether the property is considered part of the Partition Key.",
            Description = "This will implement `IPartitionKey` for the generated entity.")]
        public bool? PartitionKey { get; set; }

        /// <summary>
        /// Gets or sets the names of the secondary property(s), comma delimited, that are to be notified on a property change.
        /// </summary>
        [JsonProperty("secondaryPropertyChanged", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Property", Title = "The names of the secondary property(s), comma delimited, that are to be notified on a property change.")]
        public string? SecondaryPropertyChanged { get; set; }

        /// <summary>
        /// Indicates whether the value should bubble up property changes versus only recording within the sub-entity itself.
        /// </summary>
        [JsonProperty("bubblePropertyChanges", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Property", Title = "Indicates whether the value should bubble up property changes versus only recording within the sub-entity itself.",
            Description = "Note that the `IsEntity` property is also required to enable.")]
        public bool? BubblePropertyChanged { get; set; }

        /// <summary>
        /// Indicates that CleanUp is not to be performed for the property within the Entity.CleanUp method.
        /// </summary>
        [JsonProperty("excludeCleanup", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Property", Title = "Indicates that `CleanUp` is not to be performed for the property within the `Entity.CleanUp` method.")]
        public bool? ExcludeCleanup { get; set; }

        /// <summary>
        /// Indicates whether the property is for internal use only; declared in the Business entities only.
        /// </summary>
        [JsonProperty("internalOnly", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Property", Title = "Indicates whether the property is for internal use only; declared in Business entities only.",
            Description = "This is only applicable where the `Entity.EntityScope` is `Autonomous`. In this instance the `Property` will be excluded from the `Common` entity declaration.")]
        public bool? InternalOnly { get; set; }

        #endregion

        #region RefData

        /// <summary>
        /// Gets or sets the underlying Reference Data Type that is also used as the Reference Data serialization identifier (SID).
        /// </summary>
        [JsonProperty("refDataType", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("RefData", Title = "The underlying Reference Data Type that is also used as the Reference Data serialization identifier (SID).", Options = new string[] { "string", "int", "Guid" },
            Description = "Defaults to `string` (being the `ReferenceDataBase.Code`) where not specified and the corresponding `Type` starts with (prefix) `RefDataNamespace.` or `^`. Note: an `Id` of type `string` is currently not supported; the use of the `Code` is the recommended approach.")]
        public string? RefDataType { get; set; }

        /// <summary>
        /// Indicates that the Reference Data property is to be a serializable list (ReferenceDataSidList). 
        /// </summary>
        [JsonProperty("refDataList", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("RefData", Title = "Indicates that the Reference Data property is to be a serializable list (`ReferenceDataSidList`).",
            Description = "This is required to enable a list of Reference Data values (as per `RefDataType`) to be passed as an argument for example.")]
        public bool? RefDataList { get; set; }

        /// <summary>
        /// Indicates whether a corresponding <i>text</i> property is added when generating a Reference Data property overriding the <c>CodeGeneration.RefDataText</c> selection.
        /// </summary>
        [JsonProperty("refDataText", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("RefData", Title = "Indicates whether a corresponding `Text` property is added when generating a Reference Data property, overriding the `Entity.RefDataText` selection.",
            Description = "This is used where serializing within the Web API `Controller` and the `ExecutionContext.IsRefDataTextSerializationEnabled` is set to `true` (which is automatically set where the url contains `$text=true`).")]
        public bool? RefDataText { get; set; }

        /// <summary>
        /// Indicates whether the property should use the underlying Reference Data mapping capabilities. 
        /// </summary>
        [JsonProperty("refDataMapping", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("RefData", Title = "Indicates whether the property should use the underlying Reference Data mapping capabilities.",
            Description = "Mapped properties are a special Reference Data property type that ensure value uniqueness; this allows the likes of additional to/from mappings to occur between systems where applicable.")]
        public bool? RefDataMapping { get; set; }

        #endregion

        #region Serialization

        /// <summary>
        /// Gets or sets the JSON property name.
        /// </summary>
        [JsonProperty("jsonName", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Serialization", Title = "The JSON property name.",
            Description = "Defaults to `ArgumentName` where not specified (i.e. camelCase); however, where the property is `ETag` it will default to the `Config.ETagJsonName`.")]
        public string? JsonName { get; set; }

        /// <summary>
        /// Gets or sets the JSON property name for the corresponding data model.
        /// </summary>
        [JsonProperty("jsonDataModelName", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Serialization", Title = "The JSON property name for the corresponding data model (see `Entity.DataModel`).",
            Description = "Defaults to `JsonName` where not specified.")]
        public string? JsonDataModelName { get; set; }

        /// <summary>
        /// Indicates whether the property is not to be serialized.
        /// </summary>
        [JsonProperty("serializationIgnore", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Serialization", Title = "Indicates whether the property is not to be serialized.",
            Description = "All properties are serialized by default.")]
        public bool? SerializationIgnore { get; set; }

        /// <summary>
        /// Indicates whether to emit the default value when serializing.
        /// </summary>
        [JsonProperty("serializationEmitDefault", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Serialization", Title = "Indicates whether to emit the default value when serializing.")]
        public bool? SerializationEmitDefault { get; set; }

        /// <summary>
        /// Gets or sets the override JSON property name where outputting as a data model.
        /// </summary>
        [JsonProperty("dataModelJsonName", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Serialization", Title = "The override JSON property name where outputting as a data model.",
            Description = "Defaults to `JsonName` where not specified.")]
        public string? DataModelJsonName { get; set; }

        #endregion

        #region Manager

        /// <summary>
        /// Gets or sets the Identifier Generator Type to generate the identifier on create via Dependency Injection (<see cref="Entities.IIdentifierGenerator"/>).
        /// </summary>
        [JsonProperty("identifierGenerator", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Manager", Title = "The Identifier Generator Type to generate the identifier on create via Dependency Injection.",
            Description = "Should be formatted as `Type` + `^` + `Name`; e.g. `IGuidIdentifierGenerator^GuidIdGen`. Where the `Name` portion is not specified it will be inferred. " +
                "Where the `Type` matches an already inferred value it will be ignored. " +
                "See `Beef.Entities.IInt32IdentifierGenerator`, `Beef.Entities.IInt64IdentifierGenerator`, `Beef.Entities.IGuidIdentifierGenerator` or `Beef.Entities.IStringIdentifierGenerator` for underlying implementation requirements.")]
        public string? IdentifierGenerator { get; set; }

        #endregion

        #region Data
    
        /// <summary>
        /// Gets or sets the data name where `Entity.AutoImplement` is selected.
        /// </summary>
        [JsonProperty("dataName", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Data", Title = "The data name where Entity.AutoImplement is selected.", IsImportant = true,
            Description = "Defaults to the property `Name`. Represents the column name for a `Database`, or the correspinding property name for the other options.")]
        public string? DataName { get; set; }

        /// <summary>
        /// Gets or sets the data `Converter` class name where `Entity.AutoImplement` is selected.
        /// </summary>
        [JsonProperty("dataConverter", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Data", Title = "The data `Converter` class name where `Entity.AutoImplement` is selected.", IsImportant = true,
            Description = "A `Converter` is used to convert a data source value to/from a .NET `Type` where no standard data conversion can be applied. Where this value is suffixed by `<T>` or `{T}` this will automatically set `DataConverterIsGeneric` to `true`.")]
        public string? DataConverter { get; set; }

        /// <summary>
        /// Indicates whether the data `Converter` is a generic class and will automatically use the corresponding property `Type` as the generic `T`.
        /// </summary>
        [JsonProperty("dataConverterIsGeneric", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Data", Title = "Indicates whether the data `Converter` is a generic class and will automatically use the corresponding property `Type` as the generic `T`.")]
        public bool? DataConverterIsGeneric { get; set; }

        /// <summary>
        /// Indicates whether the property should be ignored (excluded) from the Data / DataMapper generated output. 
        /// </summary>
        [JsonProperty("dataMapperIgnore", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Data", Title = "Indicates whether the property should be ignored (excluded) from the `Data`-layer / data `Mapper` generated output.",
            Description = "All properties are included by default.")]
        public bool? DataMapperIgnore { get; set; }

        /// <summary>
        /// Indicates whether the `UniqueKey` property value is automatically generated by the data source on `Create`.
        /// </summary>
        [JsonProperty("dataAutoGenerated", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Data", Title = "Indicates whether the `UniqueKey` property value is automatically generated by the data source on `Create`.")]
        public bool? DataAutoGenerated { get; set; }

        /// <summary>
        /// Gets or sets the operations types (`ExecutionContext.OperationType`) selection to enable inclusion and exclusion of property mapping.
        /// </summary>
        [JsonProperty("dataOperationTypes", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Data", Title = "The operations types (`ExecutionContext.OperationType`) selection to enable inclusion and exclusion of property mapping.",
            Options = new string[] { "Any", "AnyExceptCreate", "AnyExceptUpdate", "AnyExceptGet", "Get", "Create", "Update", "Delete" },
            Description = "Defaults to `Any`.")]
        public string? DataOperationTypes { get; set; }

        #endregion

        #region Database

        /// <summary>
        /// Gets or sets the database property `Mapper` class name where `Entity.AutoImplement` is selected.
        /// </summary>
        [JsonProperty("databaseMapper", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Database", Title = "The database property `Mapper` class name where `Entity.AutoImplement` is selected.",
            Description = "A `Mapper` is used to map a data source value to/from a .NET complex `Type` (i.e. class with one or more properties).")]
        public string? DatabaseMapper { get; set; }

        /// <summary>
        /// Indicates whether the property should be ignored (excluded) from the database `Mapper` generated output.
        /// </summary>
        [JsonProperty("databaseIgnore", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Database", Title = "Indicates whether the property should be ignored (excluded) from the database `Mapper` generated output.")]
        public bool? DatabaseIgnore { get; set; }

        /// <summary>
        /// Gets or sets the database DbType override (versus inferring from the corresponding .NET Type).
        /// </summary>
        [JsonProperty("databaseDbType", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Database", Title = "The database `DbType` override (versus inferring from the corresponding .NET Type).", IsImportant = true,
            Description = "Overrides the inferred database type; i.e. can specify `Date` or `DateTime2`, for .NET Type `System.DateTime`.")]
        public string? DatabaseDbType { get; set; }

        #endregion

        #region EntityFramework

        /// <summary>
        /// The Entity Framework `Mapper` approach for the property.
        /// </summary>
        [JsonProperty("entityFrameworkMapper", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("EntityFramework", Title = "The Entity Framework `Mapper` approach for the property.", Options = new string[] { "Map", "Ignore", "Skip" },
            Description = "Defaults to `Map` which indicates the property will be explicitly mapped. A value of `Ignore` will explicitly `Ignore`, whilst a value of `Skip` will skip code-generated mapping altogether.")]
        public string? EntityFrameworkMapper { get; set; }

        #endregion

        #region Cosmos

        /// <summary>
        /// The Cosmos `Mapper` approach for the property.
        /// </summary>
        [JsonProperty("cosmosMapper", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Cosmos", Title = "The Cosmos `Mapper` approach for the property.", Options = new string[] { "Map", "Ignore", "Skip" },
            Description = "Defaults to `Map` which indicates the property will be explicitly mapped. A value of `Ignore` will explicitly `Ignore`, whilst a value of `Skip` will skip code-generated mapping altogether.")]
        public string? CosmosMapper { get; set; }

        #endregion

        #region OData

        /// <summary>
        /// The OData `Mapper` approach for the property.
        /// </summary>
        [JsonProperty("odataMapper", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("OData", Title = "The OData `Mapper` approach for the property.", Options = new string[] { "Map", "Ignore", "Skip" },
            Description = "Defaults to `Map` which indicates the property will be explicitly mapped. A value of `Ignore` will explicitly `Ignore`, whilst a value of `Skip` will skip code-generated mapping altogether.")]
        public string? ODataMapper { get; set; }

        #endregion

        #region Annotation

        /// <summary>
        /// Gets or sets the display name used in the likes of error messages for the property.
        /// </summary>
        [JsonProperty("displayName", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Annotation", Title = "The display name used in the likes of error messages for the property.",
            Description = "Defaults to the `Name` as sentence case.")]
        public string? DisplayName { get; set; }

        /// <summary>
        /// Gets or sets the property annotation (e.g. attribute) declaration code.
        /// </summary>
        [JsonProperty("annotation1", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Annotation", Title = "The property annotation (e.g. attribute) declaration code.")]
        public string? Annotation1 { get; set; }

        /// <summary>
        /// Gets or sets the property annotation (e.g. attribute) declaration code.
        /// </summary>
        [JsonProperty("annotation2", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Annotation", Title = "The property annotation (e.g. attribute) declaration code.")]
        public string? Annotation2 { get; set; }

        /// <summary>
        /// Gets or sets the property annotation (e.g. attribute) declaration code.
        /// </summary>
        [JsonProperty("annotation3", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("Annotation", Title = "The property annotation (e.g. attribute) declaration code.")]
        public string? Annotation3 { get; set; }

        #endregion

        #region WebApi

        /// <summary>
        /// Gets or sets the `IPropertyMapperConverter` to perform `Type` to `string` conversion for writing to and parsing from the query string.
        /// </summary>
        [JsonProperty("webApiQueryStringConverter", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("WebApi", Title = "The `IPropertyMapperConverter` to perform `Type` to `string` conversion for writing to and parsing from the query string.")]
        public string? WebApiQueryStringConverter { get; set; }

        #endregion

        #region Grpc

        /// <summary>
        /// Gets or sets the unique (immutable) field number required to enable gRPC support.
        /// </summary>
        [JsonProperty("grpcFieldNo", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("gRPC", Title = "The unique (immutable) field number required to enable gRPC support.", IsImportant = true)]
        public int? GrpcFieldNo { get; set; }

        /// <summary>
        /// Gets or sets the underlying gRPC data type.
        /// </summary>
        [JsonProperty("grpcType", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [PropertySchema("gRPC", Title = "The underlying gRPC data type; will be inferred where not specified.")]
        public string? GrpcType { get; set; }

        #endregion

        /// <summary>
        /// Gets the formatted summary text.
        /// </summary>
        public string? SummaryText => ToComments($"{(Type == "bool" ? "Indicates whether" : "Gets or sets the")} {Text}.");

        /// <summary>
        /// Gets the formatted summary text for the Reference Data Serialization Identifier (SID) property.
        /// </summary>
        public string? SummaryRefDataSid => CompareValue(RefDataList, true)
            ? ToComments($"Gets or sets the {{{{{Name}}}}} list using the underlying Serialization Identifier (SID).")
            : ToComments($"Gets or sets the {{{{{Name}}}}} using the underlying Serialization Identifier (SID).");

        /// <summary>
        /// Gets the formatted summary text for the Reference Data Text property.
        /// </summary>
        public string? SummaryRefDataText => ToComments($"Gets the corresponding {{{{{Name}}}}} text (read-only where selected).");

        /// <summary>
        /// Gets the formatted summary text when used in a parameter context.
        /// </summary>
        public string? ParameterSummaryText => ToComments($"{(Type == "bool" ? "Indicates whether" : "The")} {Text}.");

        /// <summary>
        /// Gets the <see cref="Name"/> formatted as see comments.
        /// </summary>
        public string? PropertyNameSeeComments => ToSeeComments(Name);

        /// <summary>
        /// Gets the computed declared property type.
        /// </summary>
        public string PropertyType => string.IsNullOrEmpty(RefDataType) 
            ? PrivateType 
            : (CompareValue(RefDataList, true) ? $"ReferenceDataSidList<{Type}, {RefDataType}>?" : CompareValue(Nullable, true) ? Type + "?" : Type!);

        /// <summary>
        /// Gets the computed declared private type.
        /// </summary>
        public string PrivateType
        {
            get
            {
                if (string.IsNullOrEmpty(RefDataType))
                    return CompareValue(Nullable, true) ? Type + "?" : Type!;

                var rt = CompareValue(RefDataList, true) ? $"List<{RefDataType}>" : RefDataType!;
                return CompareValue(Nullable, true) ? rt + "?" : rt!;
            }
        }

        /// <summary>
        /// Gets or sets the declared type including nullability.
        /// </summary>
        public string? DeclaredType { get; set; }

        /// <summary>
        /// Gets the data reader type (used for ReferenceDataData layer only).
        /// </summary>
        public string? DataReaderType => string.IsNullOrEmpty(RefDataType)
            ? DeclaredType
            : DataConverter switch
                {
                    "ReferenceDataGuidIdConverter" => "Guid",
                    "ReferenceDataNullableGuidIdConverter" => "Guid?",
                    "ReferenceDataInt32IdConverter" => "int",
                    "ReferenceDataNullableInt32IdConverter" => "int?",
                    "ReferenceDataInt64IdConverter" => "long",
                    "ReferenceDataNullableInt64IdConverter" => "long?",
                    "ReferenceDataStringIdConverter" => "string?",
                    _ => DeclaredType
                };

        /// <summary>
        /// Gets the computed property name.
        /// </summary>
        public string PropertyName => string.IsNullOrEmpty(RefDataType) ? Name! : Name! + (CompareValue(RefDataList, true) ? "Sids" : "Sid");

        /// <summary>
        /// Gets the computed argument name.
        /// </summary>
        public string PropertyArgumentName => string.IsNullOrEmpty(RefDataType) ? ArgumentName! : ArgumentName! + (CompareValue(RefDataList, true) ? "Sids" : "Sid");

        /// <summary>
        /// Gets the computed private name.
        /// </summary>
        public string PropertyPrivateName => string.IsNullOrEmpty(RefDataType) ? PrivateName! : PrivateName! + (CompareValue(RefDataList, true) ? "Sids" : "Sid");

        /// <summary>
        /// Gets the computed data mapper property name.
        /// </summary>
        public string DataMapperPropertyName => string.IsNullOrEmpty(RefDataType) ? Name! : CompareNullOrValue(DataConverter, "ReferenceDataCodeConverter") ? PropertyName : Name!;

        /// <summary>
        /// Gets or sets the data converter name.
        /// </summary>
        public string? DataConverterName => string.IsNullOrEmpty(DataConverter) ? null : $"{DataConverter}{(CompareValue(DataConverterIsGeneric, true) ? $"<{Type}>" : "")}";

        /// <summary>
        /// Gets the data converter C# code.
        /// </summary>
        public string? DataConverterCode => string.IsNullOrEmpty(DataConverter) ? null : $".SetConverter({DataConverterName}.Default!)";

        /// <summary>
        /// Gets the data converter C# code for reference data data access.
        /// </summary>
        public string? RefDataConverterCode => string.IsNullOrEmpty(DataConverter) ? null : $"{DataConverterName}.Default.ConvertToSrce(";

        /// <summary>
        /// Gets the WebAPI parameter type.
        /// </summary>
        public string WebApiParameterType => (string.IsNullOrEmpty(RefDataType) ? (string.IsNullOrEmpty(WebApiQueryStringConverter) ? Type! : "string") : (CompareValue(RefDataList, true) ? $"List<{RefDataType}>" : RefDataType!)) + (CompareValue(Nullable, true) ? "?" : "");

        /// <summary>
        /// Gets the name of the IdentifierGenerator as passed in as a parameter via DI.
        /// </summary>
        public string? IdentifierGeneratorName { get; set; }

        /// <summary>
        /// Gets or sets the gRPC converter.
        /// </summary>
        public string? GrpcConverter { get; set; }

        /// <summary>
        /// Gets or sets the gRPC mapper.
        /// </summary>
        public string? GrpcMapper { get; set; }

        /// <summary>
        /// <inheritdoc/>
        /// </summary>
        protected override void Prepare()
        {
            CheckKeyHasValue(Name);
            CheckOptionsProperties();

            Type = DefaultWhereNull(Type, () => "string");
            if (Type!.StartsWith("^"))
                Type = $"RefDataNamespace.{Type[1..]}";

            if (Type!.StartsWith("RefDataNamespace.", StringComparison.InvariantCulture))
                RefDataType = DefaultWhereNull(RefDataType, () => "string");

            if (RefDataType != null && !Type!.StartsWith("RefDataNamespace.", StringComparison.InvariantCulture))
                Type = $"RefDataNamespace.{Type}";

            if (Type!.EndsWith("?", StringComparison.InvariantCulture))
            {
                Type = Type[0..^1];
                Nullable = true;
            }

            DeclaredType = $"{Type}{(CompareValue(Nullable, true) ? "?" : "")}";

            Text = ToComments(DefaultWhereNull(Text, () =>
            {
                if (Type!.StartsWith("RefDataNamespace.", StringComparison.InvariantCulture))
                    return $"{StringConversion.ToSentenceCase(Name)} (see {ToSeeComments(Type)})";

                if (Type == "ChangeLog")
                    return $"{StringConversion.ToSentenceCase(Name)} (see {ToSeeComments("Beef.Entities." + Type)})";

                var ent = Root!.Entities.FirstOrDefault(x => x.Name == Type);
                if (ent != null)
                {
                    if (ent.EntityScope == null || ent.EntityScope == "Common")
                        return $"{StringConversion.ToSentenceCase(Name)} (see {ToSeeComments("Common.Entities." + Type)})";
                    else
                        return $"{StringConversion.ToSentenceCase(Name)} (see {ToSeeComments("Business.Entities." + Type)})";
                }

                return StringConversion.ToSentenceCase(Name);
            }));

            PrivateName = DefaultWhereNull(PrivateName, () => StringConversion.ToPrivateCase(Name));
            ArgumentName = DefaultWhereNull(ArgumentName, () => StringConversion.ToCamelCase(Name));
            DateTimeTransform = DefaultWhereNull(DateTimeTransform, () => "UseDefault");
            StringTrim = DefaultWhereNull(StringTrim, () => "UseDefault");
            StringTransform = DefaultWhereNull(StringTransform, () => "UseDefault");
            RefDataText = DefaultWhereNull(RefDataText, () => Parent!.RefDataText);
            DisplayName = DefaultWhereNull(DisplayName, () => GenerateDisplayName());
            Nullable = DefaultWhereNull(Nullable, () => !IgnoreNullableTypes.Contains(Type!));
            JsonName = DefaultWhereNull(JsonName, () => Name == "ETag" ? Root!.ETagJsonName : ArgumentName);
            JsonDataModelName = DefaultWhereNull(JsonDataModelName, () => JsonName);
            SerializationEmitDefault = DefaultWhereNull(SerializationEmitDefault, () => CompareValue(UniqueKey, true));
            DataModelJsonName = DefaultWhereNull(DataModelJsonName, () => JsonName);
            DataOperationTypes = DefaultWhereNull(DataOperationTypes, () => "Any");
            IsEntity = DefaultWhereNull(IsEntity, () => (Type == "ChangeLog" || Parent!.Parent!.Entities!.Any(x => x.Name == Type)) && RefDataType == null);
            Immutable = DefaultWhereNull(Immutable, () => RefDataMapping.HasValue && RefDataMapping.Value == true);
            BubblePropertyChanged = DefaultWhereNull(BubblePropertyChanged, () => CompareValue(IsEntity, true));

            DataConverter = DefaultWhereNull(DataConverter, () => string.IsNullOrEmpty(RefDataType) ? null : Root!.RefDataDefaultMapperConverter);
            if (!string.IsNullOrEmpty(DataConverter) && (DataConverter.EndsWith("{T}", StringComparison.InvariantCulture) || DataConverter.EndsWith("<T>", StringComparison.InvariantCulture)))
            {
                DataConverterIsGeneric = true;
                DataConverter = DataConverter![0..^3];
            }

            if (CompareValue(RefDataType, "string") && CompareValue(DataConverter, "ReferenceDataCodeConverter"))
                DataConverter = null;

            if (!string.IsNullOrEmpty(IdentifierGenerator))
            {
                var pc = EntityConfig.CreateParameterConfigFromInterface(IdentifierGenerator);
                if (pc != null)
                {
                    IdentifierGenerator = pc.Type;
                    IdentifierGeneratorName = pc.Name;
                }
            }

            EntityFrameworkMapper = DefaultWhereNull(EntityFrameworkMapper, () => "Map");
            CosmosMapper = DefaultWhereNull(CosmosMapper, () => "Map");
            ODataMapper = DefaultWhereNull(ODataMapper, () => "Map");

            GrpcType = DefaultWhereNull(GrpcType, () => InferGrpcType(string.IsNullOrEmpty(RefDataType) ? Type! : RefDataType!, RefDataType, RefDataList, DateTimeTransform));
            GrpcMapper = SystemTypes.Contains(Type) || RefDataType != null ? null : Type;
            GrpcConverter = Type switch
            {
                "DateTime" => $"{(CompareValue(Nullable, true) ? "Nullable" : "")}{(DateTimeTransform == "DateOnly" ? "DateTimeToDateOnly" : "DateTimeToTimestamp")}",
                "Guid" => $"{(CompareValue(Nullable, true) ? "Nullable" : "")}GuidToStringConverter",
                "decimal" => $"{(CompareValue(Nullable, true) ? "Nullable" : "")}DecimalToDecimalConverter",
                _ => null
            };
        }

        /// <summary>
        /// Generates the display name (checks for Id and handles specifically).
        /// </summary>
        private string GenerateDisplayName()
        {
            var dn = StringConversion.ToSentenceCase(Name)!;
            var parts = dn.Split(' ');
            if (parts.Length == 1)
                return (parts[0] == "Id") ? "Identifier" : dn;

            if (parts.Last() != "Id")
                return dn;

            var parts2 = new string[parts.Length - 1];
            Array.Copy(parts, parts2, parts.Length - 1);
            return string.Join(" ", parts2);
        }

        /// <summary>
        /// Infers the gRPC data type.
        /// </summary>
        internal static string InferGrpcType(string type, string? refDataType = null, bool? refDataList = null, string? dateTimeTransform = null)
        {
            var gt = type switch
            {
                "string" => "google.protobuf.StringValue",
                "bool" => "google.protobuf.BoolValue",
                "double" => "google.protobuf.DoubleValue",
                "float" => "google.protobuf.FloatValue",
                "int" => "google.protobuf.Int32Value",
                "long" => "google.protobuf.Int64Value",
                "unit" => "google.protobuf.UInt32Value",
                "ulong" => "google.protobuf.UInt64Value",
                "short" => "google.protobuf.Int32Value",  // Not natively supported
                "ushort" => "google.protobuf.UInt32Value", // Not natively supported
                "Guid" => "google.protobuf.StringValue", // Not natively supported
                "byte[]" => "bytes", // Not natively supported
                "Decimal" => "Decimal", // Not natively supported
                "DateTime" => string.Compare(dateTimeTransform, "DateOnly", StringComparison.InvariantCulture) == 0 ? "DateOnly" : "google.protobuf.Timestamp", // DateOnly not natively supported
                "TimeSpan" => "google.protobuf.Duration",
                "void" => "google.protobuf.Empty",
                _ => type
            };

            return !string.IsNullOrEmpty(refDataType) && CompareValue(refDataList, true) ? "repeated " + gt : gt;
        }
    }
}